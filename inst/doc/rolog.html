<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Matthias Gondan (Department of Psychology, Universität Innsbruck, Austria) and Jan Wielemaker (Vrije Universiteit Amsterdam/SWI-Prolog Solutions b.v.)" />

<meta name="date" content="2023-01-27" />

<title>rolog: Prolog queries from R</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">

div.csl-bib-body { }
div.csl-entry {
clear: both;
}
.hanging div.csl-entry {
margin-left:2em;
text-indent:-2em;
}
div.csl-left-margin {
min-width:2em;
float:left;
}
div.csl-right-inline {
margin-left:2em;
padding-left:1em;
}
div.csl-indent {
margin-left: 2em;
}
</style>

<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">rolog: Prolog queries from R</h1>
<h4 class="author">Matthias Gondan (Department of Psychology,
Universität Innsbruck, Austria) and Jan Wielemaker (Vrije Universiteit
Amsterdam/SWI-Prolog Solutions b.v.)</h4>
<h4 class="date">2023-01-27</h4>



<p>Matthias Gondan<br />
Universität Innsbruck<br />
Department of Psychology<br />
Innrain 9<br />
A-6020 Innsbruck<br />
<a href="mailto:Matthias.Gondan-Rochon@uibk.ac.at" class="email">Matthias.Gondan-Rochon@uibk.ac.at</a></p>
<div id="abstract" class="section level1">
<h1>Abstract</h1>
<p>Prolog is a classical logic programming language with many
applications in expert systems, computer linguistics and traditional,
that is, symbolic artificial intelligence. The main strength of Prolog
is its concise representation of facts and rules for the representation
of knowledge and grammar, as well as its efficient built-in search
engine for closed world domains. R is a statistical programming language
for data analysis and statistical modeling which is widely used in
academia and industry. Besides the core library, a lot of packages have
been developed for all kinds of statistical problems, including
statistics-based artificial intelligence tools such as neural networks
for machine learning and deep learning. Whereas Prolog is weak in
statistical computation, but strong in symbolic manipulation, the
converse may be said for the R language. SWI-Prolog is a widely used
Prolog system that offers a wide range of extensions for real world
applications, and there already exist two Prolog “packs” to invoke R
(<code>rserve-client</code>, <code>real</code>) from SWI-Prolog. Given
the large user community of R, there may also be a need for a connection
in the reverse direction that allows invoking Prolog queries in R
computations. The R package <code>rolog</code> connects to the
SWI-Prolog system, thus enabling deterministic and non-deterministic
queries to the Prolog interpreter. Usage of <code>rolog</code> is
illustrated by a few examples.</p>
<div id="keywords" class="section level2">
<h2>Keywords</h2>
<p>Statistics; Logic Programming; Artificial Intelligence; R; Prolog</p>
</div>
</div>
<div id="rolog-prolog-queries-from-r" class="section level1">
<h1>1. rolog: Prolog queries from R</h1>
<p>The R <span class="citation">(R Core Team 2021)</span> programming
language and environment is a widely used open source software for
statistical data analysis. The basic R is a functional language with
lots of support for storage and manipulation of different data types,
and a strong emphasis on operations involving vectors and arrays.
Moreover, a huge number of packages (e.g., CRAN, <a href="https://cran.r-project.org/" class="uri">https://cran.r-project.org/</a>) have been contributed that
cover problems from areas as diverse as bioinformatics, machine
learning, specialized statistical methods, web programming and
connections to other programming languages.</p>
<p>An interface to Prolog is lacking so far. Based on earlier work by
Kowalski, the logic programming language Prolog was invented in the
1970ies by Colmerauer and Roussel <span class="citation">(Kowalski
1988)</span>, mostly for the purpose of natural language processing.
Since then, logic programming has become an important driving force in
research on artificial intelligence, natural language processing,
program analysis, knowledge representation and theorem proving <span class="citation">(Shoham 1994; Lally and Fodor 2011; Carro 2004; Hsiang
and Srivas 1987)</span>. SWI-Prolog <span class="citation">(Wielemaker
et al. 2012)</span> is an open-source implementation of Prolog that
mainly targets developers of applications, with many users in academia,
research and industry. SWI-Prolog includes a large number of libraries
for “the real world”, for example, a web server, encryption, interfaces
to C/C++ and other programming languages, as well as a development
environment and debugger. In addition, pluggable extensions (so-called
packs) are available for specific tasks to enhance its capabilities.</p>
<p>Unlike R, Prolog is a declarative programming language consisting of
facts and rules that define relations, for example, in a problem space
<span class="citation">(Newell and Simon 1972)</span>. Prolog’s major
strength is its built-in query-driven search engine that efficiently
deals with complex structured data, with the data not necessarily being
numerical. In fact, Prolog only provides a basic collection of
arithmetic calculations via a purely functional interface
(<code>is/2</code>). More complex calculations such as matrix algebra,
statistical models or machine learning need help from other systems, for
example, from R.</p>
<p>Angelopoulos et al. <span class="citation">(2013)</span> summarize
work at the intersection of symbolic knowledge representation and
statistical inference, especially in the area of model fits <span class="citation">(EM algorithms, MCMC, Sato and Kameya 2013;
Angelopoulos and Cussens 2008)</span> and stochastic logic programs
<span class="citation">(Cussens 2000; Kimmig et al. 2011)</span>. One of
the major strengths of logic programming is handling constraints; and a
number of systems for constraint satisfaction tools have been developed
(constraint logic programming on booleans, finite domains, reals, and
intervals) for that purpose <span class="citation">(e.g., Frühwirth
1998; Triska 2018)</span>. Some constraint handlers exist in R (see the
CRAN task view for optimization problems), but more of them would be
available via a bridge between R and Prolog.</p>
<p>Earlier approaches to connect Prolog and R have been published as
SWI-Prolog packs <span class="citation">(real, rserve_client,
Angelopoulos et al. 2013; Wielemaker 2021b)</span> and as a YAP module
<span class="citation">(YapR, Azevedo 2011)</span>. Whereas
<code>real</code> establishes a direct link to an embedded instance of
R, <code>rserve-client</code> communicates with a local or remote R
service <span class="citation">(Urbanek 2021)</span>. The former
approach emphasizes speed, the latter might be preferred from a security
perspective, especially in systems such as SWISH <span class="citation">(Wielemaker, Lager, and Riguzzi 2015)</span> that
accept only a set of sandboxed commands for Prolog, but do not impose
restrictions on R. A common feature of the two packages is that they
provide an interface for R calls from Prolog, but not the other way
round, that is, querying Prolog from R is not possible, so far.</p>
<p>The present package fills this gap through Prolog queries in R
scripts, for example, to perform efficient symbolic computations,
searches in complex graphs, parsing natural language and definite clause
grammars. In addition, two Prolog predicates are provided that enable
Prolog to ring back to the R system for bidirectional communication.
Similar to <code>real</code>, tight communication between the two
systems is established by linking to a shared library that embeds the
current SWI-Prolog runtime. The exchange of data is facilitated by the
C++ interfaces of the two languages <span class="citation">(Eddelbuettel
and Balamuta 2018; Wielemaker 2021a)</span>. A less tight connection
might be established using the recently developed machine query
interface <span class="citation">(Zinda 2021)</span> that allows
socket-based communication between foreign languages and SWI-Prolog
(and, in fact, the <code>MQI</code> documentation includes an example in
which R is called).</p>
<p>A bidirectional bridge between R and Prolog might overcome the
limitations of both languages, thereby combining the extensive numerical
and statistical power of the R system with Prolog’s skills in the
representation of knowledge and reasoning. In addition to the useful
little tools shown in the examples below, <code>rolog</code> can
therefore contribute to progress at the intersection of traditional
artificial intelligence and contemporary statistical programming.</p>
<p>The next section presents the interface of <code>rolog</code> in
detail. Section 3 presents possible extensions of the package at both
ends, in R and Prolog. Section 4 is a list of illustrative examples that
offer useful extensions to the R system. Conclusions and further
perspectives are summarized in Section 5.</p>
</div>
<div id="basic-syntax" class="section level1">
<h1>2. Basic syntax</h1>
<p><code>rolog</code> has a rather minimalistic syntax, providing only
the basic ingredients to establish communication with the SWI-Prolog
runtime. Ways to extend the interface are described in Section 3.</p>
<p>After installation with <code>install.packages(&quot;rolog&quot;)</code>, the
package is loaded in the standard way.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">library</span>(rolog)</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="co">#&gt; Found SWI-Prolog at /usr/local/lib/swipl</span></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="co">#&gt; Welcome to SWI-Prolog (threaded, 64 bits, version 9.3.17-28-g6f1f90eab-DIRTY)</span></span></code></pre></div>
<p>We can see a short message telling the user which SWI-Prolog was
found. The package searches for SWI-Prolog based on the environment
variable <code>SWI_HOME_DIR</code>, the registry (Windows only), an
executable <code>swipl</code> in the <code>PATH</code>, and if
everything fails, R package <code>rswipl</code> <span class="citation">(Gondan 2023)</span>. The message can be silenced by
the usual option <code>quietly=TRUE</code> of the <code>library</code>
command.</p>
<div id="r-interface" class="section level2">
<h2>R interface</h2>
<p>Most of the work is done using the three R functions
<code>query</code>, <code>submit</code>, and <code>clear</code>. The R
program in Listing 1 illustrates a query to Prolog’s
<code>member/2</code> using <code>rolog</code>’s syntax rules.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="co"># member(1, [1, 2.0, a, &quot;b&quot;, X, true])</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a><span class="fu">query</span>(<span class="fu">call</span>(<span class="st">&quot;member&quot;</span>, <span class="dv">1</span><span class="dt">L</span>, <span class="fu">list</span>(<span class="dv">1</span><span class="dt">L</span>, <span class="fl">2.0</span>, <span class="fu">quote</span>(a), <span class="st">&quot;b&quot;</span>, <span class="fu">expression</span>(X), <span class="cn">TRUE</span>)))</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a><span class="co">#&gt; attr(,&quot;query&quot;)</span></span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a><span class="co">#&gt; [1] &quot;member(1, [1, 2.0, a, b, X, true])&quot;</span></span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a><span class="co"># returns an empty list, stating that member(1, [1 | _]) is satisfied</span></span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a><span class="fu">submit</span>()</span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a><span class="co">#&gt; list()</span></span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" tabindex="-1"></a><span class="co"># returns a list with constraints, stating that the query is also satisfied </span></span>
<span id="cb2-12"><a href="#cb2-12" tabindex="-1"></a><span class="co"># if the fifth element of the list, X, is 1</span></span>
<span id="cb2-13"><a href="#cb2-13" tabindex="-1"></a><span class="fu">submit</span>()</span>
<span id="cb2-14"><a href="#cb2-14" tabindex="-1"></a><span class="co">#&gt; $X</span></span>
<span id="cb2-15"><a href="#cb2-15" tabindex="-1"></a><span class="co">#&gt; [1] 1</span></span>
<span id="cb2-16"><a href="#cb2-16" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" tabindex="-1"></a><span class="co"># close the query</span></span>
<span id="cb2-18"><a href="#cb2-18" tabindex="-1"></a><span class="fu">clear</span>()</span></code></pre></div>
<dl>
<dt>Listing 1.</dt>
<dd>
A query to Prolog’s <code>member/2</code> predicate.
</dd>
</dl>
<p><code>query</code>. The function <code>query(call, options)</code> is
used to create a Prolog query (without invoking it yet). The first
argument is a regular R call that is created using R’s function
<code>call(name, ...)</code>. This call represents the Prolog query that
will be submitted in the later course. The creation of such predicates
and Prolog terms is described below and can become quite contrived (see
the examples in Section 4). The second argument, <code>options</code>,
may be used for ad hoc modifications of the translation between R and
Prolog, see the section below. The function returns <code>TRUE</code> on
success. Note that <code>query</code> does not check if a Prolog
predicate corresponding to <code>call</code> actually exists (see
<code>submit()</code> below). Only a single query can be opened at a
given time. If a new query <em>Q</em> is created while another query
<em>R</em> is still open, a warning is shown and <em>R</em> is
closed.</p>
<p><code>submit</code>. Once a query has been created, it can be
submitted using <code>submit()</code>. If the query fails, the return
value is <code>FALSE</code>. If the query succeeds, a list of
constraints is returned, with bindings for the variables that satisfy
the query. Repeated calls to submit are possible, returning the
different solutions of a query (until it eventually fails). The
distinction between the different types of return values for success and
failure (list vs. <code>FALSE</code>) is facilitated by the R function
<code>isFALSE(x)</code>.</p>
<p><code>clear</code>. Closes the query. The name of the function was
chosen to avoid name clashes with R’s own built-in function
<code>close</code>. The function returns an invisible <code>TRUE</code>,
even if there is no open query.</p>
<p>Three more functions <code>consult</code>, <code>once</code>, and
<code>findall</code> are provided for convenience.</p>
<p><code>consult</code>. In most applications, a number of Prolog facts
and rules will be loaded into the system. To facilitate this recurrent
task, the Prolog directive <code>consult/1</code> has been mirrored into
R, <code>consult(filename)</code>, with <code>filename</code> being a
string or a vector of strings if multiple files are to be consulted. The
function returns <code>TRUE</code> on success; in case of problems, it
returns <code>FALSE</code> and an error message is shown.</p>
<p><code>once</code> and <code>findall</code>. The function
<code>once(call, options)</code> is a convenience function that acts as
a shortcut for <code>query(call, options)</code>, <code>submit()</code>,
and <code>clear()</code>. Similarly, <code>findall(call, options)</code>
abbreviates the commands <code>query(call, options)</code>, repetition
of <code>submit()</code> until failure, and <code>clear()</code>,
returning a list collecting the return values of the individual
submissions.</p>
</div>
<div id="creating-prolog-terms-in-r" class="section level2">
<h2>Creating Prolog terms in R</h2>
<p>Table 1 summarizes the rules for the translation from R objects to
Prolog. Most rules work in both directions, but a few exceptions
exist.</p>
<dl>
<dt>Table 1</dt>
<dd>
Creating Prolog terms from R
</dd>
</dl>
<table>
<colgroup>
<col width="32%" />
<col width="34%" />
<col width="33%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">R</th>
<th align="left">Prolog</th>
<th align="left">Note/Alternatives</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>expression(X)</code></td>
<td align="left">Variable X</td>
<td align="left">not necessarily uppercase</td>
</tr>
<tr class="even">
<td align="left"><code>as.symbol(abc)</code></td>
<td align="left">Atom abc</td>
<td align="left"><code>as.name</code>, <code>quote</code></td>
</tr>
<tr class="odd">
<td align="left"><code>TRUE</code>, <code>FALSE</code>,
<code>NULL</code></td>
<td align="left">Atoms true, false, null</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><code>&quot;abc&quot;</code></td>
<td align="left">String &quot;abc&quot;</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"><code>3L</code></td>
<td align="left">Integer 3</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><code>3</code></td>
<td align="left">Float 3.0</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"><code>call(&quot;term&quot;, 1L, 2L)</code></td>
<td align="left">term(1, 2)</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><code>list(1L, 2L, 3L)</code></td>
<td align="left">List [1, 2, 3]</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"><code>list(a=1, b=2, c=3)</code></td>
<td align="left">List [a-1, b-2, c-3]</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><code>c(1, 2, 3, Inf)</code></td>
<td align="left">##(1.0, 2.0, 3.0, 1.0Inf)</td>
<td align="left">vectors of length &gt; 1</td>
</tr>
<tr class="odd">
<td align="left"><code>c(1L, 2L, 3L)</code> or <code>1:3</code></td>
<td align="left">&#39;%%&#39;(1, 2, 3)</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><code>c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</code></td>
<td align="left">$$(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"><code>c(TRUE, FALSE, NA)</code></td>
<td align="left">!!(true, false, na)</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><code>sin</code></td>
<td align="left">function(x) :- sin(x)</td>
<td align="left">primitive function</td>
</tr>
<tr class="odd">
<td align="left"><code>function(x) sin(x)</code></td>
<td align="left">function(x) :- sin(x)</td>
<td align="left">self-written function</td>
</tr>
<tr class="even">
<td align="left"><code>matrix(1:4, nrow=2)</code></td>
<td align="left">&#39;%%%&#39;(&#39;%%&#39;(1, 3), …)</td>
<td align="left">see also ###, $$$, !!!</td>
</tr>
</tbody>
</table>
<p>In R, the basic elements such as integers, floating point numbers,
character strings, and logicals are vectorized, and scalar entities are
treated like vectors with one element. Conversely, Prolog does not
natively support vectors or matrices. The problem is solved in the
following way:</p>
<ul>
<li>R vectors of length 0 are translated to Prolog’s empty list.</li>
<li>R vectors of length 1 are translated to Prolog scalars.</li>
<li>R vectors of length <span class="math inline">\(N &gt; 1\)</span>
are translated to Prolog terms <code>##/N</code>, <code>%%/N</code>,
<code>$$/N</code>, and <code>!!/N</code> for floating point numbers,
integers, strings and logicals, respectively.</li>
<li>R matrices are translated to Prolog terms <code>###/R</code>,
<code>%%%/R</code>, <code>$$$/R</code>, and <code>!!!/R</code> with the
respective row vectors as arguments.</li>
</ul>
<p>In the reverse direction, Prolog terms like <code>##/N</code> are
translated back to R vectors of length <em>N</em>, including the terms
<code>##/0</code> and <code>##/1</code> that map to R vectors of length
0 and 1, respectively. Translation of a polymorphic Prolog term such as
<code>##(a, 1.5)</code> to R will fail, since <code>rolog</code> expects
the arguments to be numeric.</p>
<p>If a Prolog object cannot be translated to R (e.g., a cyclic term),
an error is raised. If an R object that lacks a suitable representation
in Prolog (e.g., S4 class), a warning is printed and the result is
unified with <code>na</code>.</p>
<p>To summarize, the rules for translation are not fully symmetrical. A
quick check for symmetry of the representation is obtained by a query to
<code>=/2</code> or even <code>r_eval/2</code> (see also below,
subsection Prolog interface):</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>Q <span class="ot">&lt;-</span> <span class="fu">call</span>(<span class="st">&quot;=&quot;</span>, <span class="fu">expression</span>(X), <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="cn">NA</span>, <span class="cn">NaN</span>, <span class="cn">Inf</span>))</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a><span class="fu">once</span>(Q, <span class="at">options=</span><span class="fu">list</span>(<span class="at">portray=</span><span class="cn">TRUE</span>))</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a><span class="co">#&gt; $X</span></span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a><span class="co">#&gt; [1]   1   2  NA NaN Inf</span></span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a><span class="co">#&gt; attr(,&quot;query&quot;)</span></span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a><span class="co">#&gt; [1] &quot;X= ##(1.0, 2.0, na, 1.5NaN, 1.0Inf)&quot;</span></span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a>Q <span class="ot">&lt;-</span> <span class="fu">call</span>(<span class="st">&quot;r_eval&quot;</span>, <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="cn">NA</span>, <span class="cn">NaN</span>, <span class="cn">Inf</span>), <span class="fu">expression</span>(X))</span>
<span id="cb3-10"><a href="#cb3-10" tabindex="-1"></a><span class="fu">once</span>(Q)</span>
<span id="cb3-11"><a href="#cb3-11" tabindex="-1"></a><span class="co">#&gt; $X</span></span>
<span id="cb3-12"><a href="#cb3-12" tabindex="-1"></a><span class="co">#&gt; [1]   1   2  NA NaN Inf</span></span></code></pre></div>
<p>The optional argument <code>env</code> to query, once and findall
allows to raise the query (and, as a consequence, r_eval/1,2 in a
specific environment.</p>
</div>
<div id="package-options" class="section level2">
<h2>Package options</h2>
<p>A few package-specific options have been defined to allow some
fine-tuning of the rules for translation between R and Prolog.</p>
<ul>
<li><em>realvec</em> (string): Name of the Prolog term for vectors of
floats (default is <code>##</code>)</li>
<li><em>realmat</em>: Name of the Prolog term for matrices of floats
(default is <code>###</code>)</li>
<li><em>intvec</em>/<em>intmat</em>: same for vectors/matrices of
integers (defaults are <code>%%</code>/<code>%%%</code>)</li>
<li><em>boolvec</em>/<em>boolmat</em>: same for vectors/matrices of
logicals (defaults are <code>!!</code>/<code>!!!</code>)</li>
<li><em>charvec</em>/<em>charmat</em> (string): same for
vectors/matrices of character strings (defaults are
<code>$$</code>/<code>$$$</code>). The single dollar cannot be used
because it is the list operator in R.</li>
<li><em>scalar</em> (logical): if <code>TRUE</code> (default), R vectors
of length 1 are translated to scalars in Prolog. If <code>FALSE</code>
(rarely used), R vectors are always translated to <code>##/N</code>, or
<code>%%/N</code>, <code>!!/N</code>, <code>$$/N</code>, even if they
have only one element.</li>
<li><em>portray</em> (logical): if <code>TRUE</code> (default in
<code>query</code>), the result of <code>query</code>, <code>once</code>
and <code>findall</code> includes an attribute with a text
representation of the query in Prolog.</li>
<li><em>preproc</em> (function with one argument): R hook that can be
used to preprocess R terms before translation. The default is
<code>rolog</code>’s own <code>preproc</code> function that maps R’s
<code>x &lt;= y</code> to Prolog’s <code>x =&lt; y</code> and
<code>!=</code> to <code>\=</code>. Preprocessing can be turned off by
assigning the R function <code>dontCheck</code> to the preproc
option.</li>
<li><em>postproc</em> (function with one argument): R hook that can be
used to postprocess R terms after a query. The default is
<code>rolog</code>’s own <code>postproc</code> function that reverses
the mapping from <code>preproc</code>.</li>
</ul>
<p>The command <code>rolog_options()</code> returns a list with all the
options. The options can be globally modified with
<code>options()</code> or in the optional argument of
<code>query</code>, <code>once</code>, and <code>findall</code>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="fu">options</span>(<span class="at">rolog.intvec=</span><span class="st">&quot;iv&quot;</span>)</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>Q <span class="ot">&lt;-</span> <span class="fu">call</span>(<span class="st">&quot;member&quot;</span>, <span class="fu">expression</span>(X), <span class="fu">list</span>(<span class="fu">c</span>(<span class="dv">1</span><span class="dt">L</span>, <span class="dv">2</span><span class="dt">L</span>), <span class="fu">c</span>(<span class="fl">3.5</span>, <span class="fl">4.5</span>)))</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a><span class="fu">query</span>(Q, <span class="at">options=</span><span class="fu">list</span>(<span class="at">realvec=</span><span class="st">&quot;rv&quot;</span>))</span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a><span class="co">#&gt; attr(,&quot;query&quot;)</span></span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a><span class="co">#&gt; [1] &quot;member(X, [iv(1, 2), rv(3.5, 4.5)])&quot;</span></span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a><span class="fu">submit</span>()</span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a><span class="co">#&gt; $X</span></span>
<span id="cb4-9"><a href="#cb4-9" tabindex="-1"></a><span class="co">#&gt; [1] 1 2</span></span>
<span id="cb4-10"><a href="#cb4-10" tabindex="-1"></a><span class="fu">clear</span>()</span></code></pre></div>
</div>
<div id="prolog-interface-to-r" class="section level2">
<h2>Prolog interface to R</h2>
<p><code>rolog</code> offers some basic support to call R from Prolog,
that is, connecting the two systems in the reverse direction. Two
predicates can be used for this purpose, <code>r_eval(Call)</code> and
<code>r_eval(Function, Result)</code>. The former just invokes R with
the command <code>Call</code> (ignoring the result); the latter
evaluates <code>Function</code> and unifies the result with
<code>Result</code>. Note that proper quoting of R functions is needed
at the Prolog end, especially with R functions that start with uppercase
letters and/or contain a dot in their name (see Section 4).</p>
</div>
<div id="exceptions" class="section level2">
<h2>Exceptions</h2>
<p>Package <code>rolog</code> has limited support for exception
handling. If Prolog raises an exception, the error string is forwarded
to R using the <code>stop</code> function. The examples below illustrate
this by querying an undefined Prolog predicate.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>Q <span class="ot">&lt;-</span> <span class="fu">call</span>(<span class="st">&quot;membr&quot;</span>, <span class="fu">expression</span>(X), <span class="fu">list</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>))</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a><span class="fu">query</span>(Q)</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a><span class="co">#&gt; attr(,&quot;query&quot;)</span></span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a><span class="co">#&gt; [1] &quot;membr(X, [1.0, 2.0, 3.0])&quot;</span></span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a><span class="fu">try</span>(<span class="fu">submit</span>())</span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a><span class="co">#&gt; Warning in .submit():</span></span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a><span class="co">#&gt; error(existence_error(procedure,membr/2),context(system:call/1,_))</span></span>
<span id="cb5-9"><a href="#cb5-9" tabindex="-1"></a><span class="co">#&gt; [1] FALSE</span></span>
<span id="cb5-10"><a href="#cb5-10" tabindex="-1"></a><span class="fu">clear</span>()</span></code></pre></div>
<p>See Section 4 for another example with an error resulting from a
malformed query to <code>r_eval/2</code>.</p>
</div>
</div>
<div id="extending-the-package" class="section level1">
<h1>3. Extending the package</h1>
<p>R is a functional language, whereas Prolog is declarative. Obviously,
there cannot be a perfect one-to-one correspondence between the
syntactic components of two programming languages that follow completely
different paradigms. Whereas symbols, functions, numbers and character
strings are easily mapped between R and Prolog, there are loose ends at
both sides. The package is intentionally kept minimalistic, but can
easily be extended by convenience functions at both ends, Prolog and R,
to facilitate recurrent tasks and/or avoid cumbersome syntax.</p>
<p>In particular, Prolog variables are translated from and to R
<em>expressions</em> (not to be confused with R symbols), and R vectors
of length greater than 1 are translated to the Prolog terms
<code>#/N</code>, <code>%/N</code>, <code>!/N</code>, and
<code>$$/N</code>, as mentioned above. These rules are, in principle,
arbitrary and can be intercepted at several stages.</p>
<ul>
<li>R functions that may be used to pre-process specific R elements
before translation to Prolog (see, e.g., the R function
<code>as.rolog</code>)</li>
<li>Prolog wrappers that manipulate the term before it is called and
afterwards (see the example with dicts below)</li>
<li>R functions that post-process the result of a query</li>
</ul>
<p>The process is illustrated in Figure 1.</p>
<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.40.1 (20161225.0304)
 -->
<!-- Title: G Pages: 1 -->
<svg width="524pt" height="140pt" viewBox="0.00 0.00 523.62 140.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 136)">
<title>G</title>
<polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-136 519.6214,-136 519.6214,4 -4,4"></polygon>
<g id="clust1" class="cluster">
<title>cluster_0</title>
<polygon fill="#d3d3d3" stroke="#d3d3d3" points="113.7627,-72 113.7627,-124 411.314,-124 411.314,-72 113.7627,-72"></polygon>
</g>
<g id="clust2" class="cluster">
<title>cluster_1</title>
<polygon fill="#d3d3d3" stroke="#d3d3d3" points="111.0327,-8 111.0327,-60 414.044,-60 414.044,-8 111.0327,-8"></polygon>
</g>
<!-- Query -->
<g id="node1" class="node">
<title>Query</title>
<polygon fill="none" stroke="#000000" points="41.5163,-125 -.0164,-100 41.5163,-75 83.049,-100 41.5163,-125"></polygon>
<polyline fill="none" stroke="#000000" points="10.2648,-106.1886 10.2648,-93.8114 "></polyline>
<polyline fill="none" stroke="#000000" points="31.2352,-81.1886 51.7975,-81.1886 "></polyline>
<polyline fill="none" stroke="#000000" points="72.7679,-93.8114 72.7679,-106.1886 "></polyline>
<polyline fill="none" stroke="#000000" points="51.7975,-118.8114 31.2352,-118.8114 "></polyline>
<text text-anchor="middle" x="41.5163" y="-95.8" font-family="Times,serif" font-size="14.00" fill="#000000">Query</text>
</g>
<!-- r2rolog -->
<g id="node3" class="node">
<title>r2rolog</title>
<polygon fill="#ffffff" stroke="#ffffff" points="180.3888,-116 121.887,-116 121.887,-80 180.3888,-80 180.3888,-116"></polygon>
<text text-anchor="middle" x="151.1379" y="-93.8" font-family="Times,serif" font-size="14.00" fill="#000000">preproc</text>
</g>
<!-- Query&#45;&gt;r2rolog -->
<g id="edge5" class="edge">
<title>Query-&gt;r2rolog</title>
<path fill="none" stroke="#000000" d="M82.0239,-99.261C91.6985,-99.0844 102.0124,-98.8963 111.6407,-98.7206"></path>
<polygon fill="#000000" stroke="#000000" points="111.8224,-102.218 121.7568,-98.536 111.6946,-95.2191 111.8224,-102.218"></polygon>
</g>
<!-- Result -->
<g id="node2" class="node">
<title>Result</title>
<polygon fill="none" stroke="#000000" points="67.2938,-56.7775 15.7389,-56.7775 15.7389,-5.2225 67.2938,-5.2225 67.2938,-56.7775"></polygon>
<polyline fill="none" stroke="#000000" points="27.7389,-56.7775 15.7389,-44.7775 "></polyline>
<polyline fill="none" stroke="#000000" points="15.7389,-17.2225 27.7389,-5.2225 "></polyline>
<polyline fill="none" stroke="#000000" points="55.2938,-5.2225 67.2938,-17.2225 "></polyline>
<polyline fill="none" stroke="#000000" points="67.2938,-44.7775 55.2938,-56.7775 "></polyline>
<text text-anchor="middle" x="41.5163" y="-26.8" font-family="Times,serif" font-size="14.00" fill="#000000">Result</text>
</g>
<!-- rolog2r -->
<g id="node6" class="node">
<title>rolog2r</title>
<polygon fill="#ffffff" stroke="#ffffff" points="183.3486,-52 118.9271,-52 118.9271,-16 183.3486,-16 183.3486,-52"></polygon>
<text text-anchor="middle" x="151.1379" y="-29.8" font-family="Times,serif" font-size="14.00" fill="#000000">postproc</text>
</g>
<!-- Result&#45;&gt;rolog2r -->
<g id="edge8" class="edge">
<title>Result-&gt;rolog2r</title>
<path fill="none" stroke="#000000" d="M77.6825,-31.9898C90.9116,-32.3518 105.7858,-32.7589 118.6719,-33.1115"></path>
<polygon fill="#000000" stroke="#000000" points="77.5872,-28.4859 67.4951,-31.711 77.3956,-35.4833 77.5872,-28.4859"></polygon>
</g>
<!-- forth -->
<g id="node4" class="node">
<title>forth</title>
<ellipse fill="#ffffff" stroke="#ffffff" cx="257.0931" cy="-98" rx="37.7006" ry="18"></ellipse>
<text text-anchor="middle" x="257.0931" y="-93.8" font-family="Times,serif" font-size="14.00" fill="#000000">(rolog)</text>
</g>
<!-- r2rolog&#45;&gt;forth -->
<g id="edge1" class="edge">
<title>r2rolog-&gt;forth</title>
<path fill="none" stroke="#000000" d="M180.6523,-98C189.3761,-98 199.1636,-98 208.7474,-98"></path>
<polygon fill="#000000" stroke="#000000" points="209.0069,-101.5001 219.0069,-98 209.0068,-94.5001 209.0069,-101.5001"></polygon>
</g>
<!-- rolog_pl -->
<g id="node5" class="node">
<title>rolog_pl</title>
<polygon fill="#ffffff" stroke="#ffffff" points="403.1355,-116 333.8516,-116 333.8516,-80 403.1355,-80 403.1355,-116"></polygon>
<text text-anchor="middle" x="368.4935" y="-93.8" font-family="Times,serif" font-size="14.00" fill="#000000">preproc/2</text>
</g>
<!-- forth&#45;&gt;rolog_pl -->
<g id="edge2" class="edge">
<title>forth-&gt;rolog_pl</title>
<path fill="none" stroke="#000000" d="M295.1192,-98C304.2843,-98 314.1616,-98 323.6074,-98"></path>
<polygon fill="#000000" stroke="#000000" points="323.6337,-101.5001 333.6337,-98 323.6336,-94.5001 323.6337,-101.5001"></polygon>
</g>
<!-- Prolog -->
<g id="node9" class="node">
<title>Prolog</title>
<ellipse fill="none" stroke="#000000" cx="478.8327" cy="-66" rx="36.5786" ry="36.5786"></ellipse>
<polyline fill="none" stroke="#000000" points="503.1648,-93.5915 454.5007,-93.5915 "></polyline>
<polyline fill="none" stroke="#000000" points="503.1648,-38.4085 454.5007,-38.4085 "></polyline>
<text text-anchor="middle" x="478.8327" y="-61.8" font-family="Times,serif" font-size="14.00" fill="#000000">Prolog</text>
</g>
<!-- rolog_pl&#45;&gt;Prolog -->
<g id="edge6" class="edge">
<title>rolog_pl:e-&gt;Prolog</title>
<path fill="none" stroke="#000000" d="M403.4935,-98C415.254,-98 427.2841,-94.6558 438.1805,-90.1297"></path>
<polygon fill="#000000" stroke="#000000" points="439.7892,-93.2427 447.429,-85.9022 436.8791,-86.8763 439.7892,-93.2427"></polygon>
</g>
<!-- back -->
<g id="node7" class="node">
<title>back</title>
<ellipse fill="#ffffff" stroke="#ffffff" cx="257.0931" cy="-34" rx="37.7006" ry="18"></ellipse>
<text text-anchor="middle" x="257.0931" y="-29.8" font-family="Times,serif" font-size="14.00" fill="#000000">(rolog)</text>
</g>
<!-- rolog2r&#45;&gt;back -->
<g id="edge3" class="edge">
<title>rolog2r-&gt;back</title>
<path fill="none" stroke="#000000" d="M193.519,-34C201.9303,-34 210.7131,-34 218.9718,-34"></path>
<polygon fill="#000000" stroke="#000000" points="193.5037,-30.5001 183.5037,-34 193.5036,-37.5001 193.5037,-30.5001"></polygon>
</g>
<!-- pl_rolog -->
<g id="node8" class="node">
<title>pl_rolog</title>
<polygon fill="#ffffff" stroke="#ffffff" points="406.0946,-52 330.8925,-52 330.8925,-16 406.0946,-16 406.0946,-52"></polygon>
<text text-anchor="middle" x="368.4935" y="-29.8" font-family="Times,serif" font-size="14.00" fill="#000000">postproc/2</text>
</g>
<!-- back&#45;&gt;pl_rolog -->
<g id="edge4" class="edge">
<title>back-&gt;pl_rolog</title>
<path fill="none" stroke="#000000" d="M305.2928,-34C313.7738,-34 322.4911,-34 330.6388,-34"></path>
<polygon fill="#000000" stroke="#000000" points="305.1193,-30.5001 295.1192,-34 305.1192,-37.5001 305.1193,-30.5001"></polygon>
</g>
<!-- pl_rolog&#45;&gt;Prolog -->
<g id="edge7" class="edge">
<title>pl_rolog:e-&gt;Prolog</title>
<path fill="none" stroke="#000000" d="M416.6536,-34.8303C427.7021,-36.5766 438.5788,-40.8717 448.0695,-45.7339"></path>
<polygon fill="#000000" stroke="#000000" points="416.7454,-31.3262 406.4935,-34 416.1752,-38.303 416.7454,-31.3262"></polygon>
</g>
</g>
</svg>

<dl>
<dt>Figure 1</dt>
<dd>
Workflow in rolog
</dd>
</dl>
<div id="preprocessing-in-r" class="section level2">
<h2>Preprocessing in R</h2>
<p><code>rolog</code> uses a default preprocessing function
<code>preproc(query)</code> to map the R operators <code>&lt;=</code>
and <code>!=</code> to their Prolog counterparts <code>=&lt;/2</code>
and <code>\=/2</code>, respectively.</p>
<p>However, we have seen above that raising even simple everyday Prolog
queries such as <code>member(X, [1, 2, 3, a, b])</code> require
complicated R expressions like
<code>call(&quot;member&quot;, expression(X), list(1, 2, 3, quote(a), quote(b)))</code>.
The R function <code>as.rolog(query)</code> is meant to simplify this a
bit by translating symbols starting with a dot to Prolog variables, and
calls like <code>&quot;&quot;[1, 2, 3, a, b]</code> to lists. In the example
below, <code>as.rolog</code> is added to the queue of preprocessing
functions.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>a <span class="ot">&lt;-</span> <span class="dv">5</span></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>Q <span class="ot">&lt;-</span> <span class="fu">quote</span>(<span class="fu">member</span>(.X, <span class="st">&quot;&quot;</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, a, (a), <span class="dv">1</span> <span class="sc">&lt;=</span> <span class="dv">2</span>]))</span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a><span class="fu">once</span>(Q, <span class="at">options=</span><span class="fu">list</span>(<span class="at">preproc=</span><span class="fu">list</span>(as.rolog, preproc), <span class="at">portray=</span><span class="cn">TRUE</span>))</span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a><span class="co">#&gt; $X</span></span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a><span class="co">#&gt; [1] 1</span></span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a><span class="co">#&gt; attr(,&quot;query&quot;)</span></span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a><span class="co">#&gt; [1] &quot;member(X, [1.0, 2.0, 3.0, a, 5.0, 1.0=&lt;2.0])&quot;</span></span></code></pre></div>
<p>Note that the name of the variable will still be <code>X</code> in
the later course, not “dot-X”. As illustrated by the example above,
<code>as.rolog</code> treats the argument <code>a</code> as a symbol; to
evaluate the respective variable (i.e., “unquote”), it can be put in
parentheses.</p>
<p>Preprocessing can be turned off by setting the option
<code>preproc</code> to the identity function
<code>dontCheck</code>.</p>
<p>Section 3 includes an example for mathematical rendering of R
expressions. In that example, a preprocessing function is used to bring
function calls with named arguments to a canonical form which is then
handled in Prolog. More sophisticated work with quasi-quotations and
unquoting expressions is described in “Advanced R” <span class="citation">(Wickham 2019)</span>.</p>
</div>
<div id="postprocessing-in-r" class="section level2">
<h2>Postprocessing in R</h2>
<p>In most cases, postprocessing will revert the manipulations during
preprocessing, and the default function <code>postproc(query)</code>
actually translates the Prolog operators <code>=&lt;</code> and
<code>\=</code> back to their respective counterparts in R.</p>
<p>Many Prolog programmers are used to operate with atoms, whereas
character strings are the preferred representation of symbolic
information in R. In the example below, a second hook is put in the
queue that converts the result of a query like
<code>member(X, [a, b, c])</code> to strings.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a>stringify <span class="ot">&lt;-</span> <span class="cf">function</span>(x)</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>{</span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">is.symbol</span>(x))</span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a>    <span class="fu">return</span>(<span class="fu">as.character</span>(x))</span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">is.call</span>(x))</span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a>    x[<span class="sc">-</span><span class="dv">1</span>] <span class="ot">&lt;-</span> <span class="fu">lapply</span>(x[<span class="sc">-</span><span class="dv">1</span>], <span class="at">FUN=</span>stringify)</span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">is.list</span>(x))</span>
<span id="cb7-10"><a href="#cb7-10" tabindex="-1"></a>    x <span class="ot">&lt;-</span> <span class="fu">lapply</span>(x, <span class="at">FUN=</span>stringify)</span>
<span id="cb7-11"><a href="#cb7-11" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">is.function</span>(x))</span>
<span id="cb7-13"><a href="#cb7-13" tabindex="-1"></a>    <span class="fu">body</span>(x) <span class="ot">&lt;-</span> <span class="fu">stringify</span>(<span class="fu">body</span>(x))</span>
<span id="cb7-14"><a href="#cb7-14" tabindex="-1"></a></span>
<span id="cb7-15"><a href="#cb7-15" tabindex="-1"></a>  <span class="fu">return</span>(x)</span>
<span id="cb7-16"><a href="#cb7-16" tabindex="-1"></a>}</span>
<span id="cb7-17"><a href="#cb7-17" tabindex="-1"></a></span>
<span id="cb7-18"><a href="#cb7-18" tabindex="-1"></a>Q <span class="ot">&lt;-</span> <span class="fu">quote</span>(<span class="fu">member</span>(.X, <span class="st">&quot;&quot;</span>[a, b, c]))</span>
<span id="cb7-19"><a href="#cb7-19" tabindex="-1"></a>R <span class="ot">&lt;-</span> <span class="fu">findall</span>(Q, <span class="at">options=</span><span class="fu">list</span>(<span class="at">preproc=</span><span class="fu">list</span>(as.rolog, preproc), </span>
<span id="cb7-20"><a href="#cb7-20" tabindex="-1"></a>       <span class="at">postproc=</span><span class="fu">list</span>(stringify, postproc)))</span>
<span id="cb7-21"><a href="#cb7-21" tabindex="-1"></a><span class="fu">unlist</span>(R)</span>
<span id="cb7-22"><a href="#cb7-22" tabindex="-1"></a><span class="co">#&gt;   X   X   X </span></span>
<span id="cb7-23"><a href="#cb7-23" tabindex="-1"></a><span class="co">#&gt; &quot;a&quot; &quot;b&quot; &quot;c&quot;</span></span></code></pre></div>
<p>In other words, the query is satisfied if <code>X</code> is either
“a”, or “b”, or “c”.</p>
</div>
<div id="pre--and-postprocessing-in-prolog" class="section level2">
<h2>Pre- and postprocessing in Prolog</h2>
<p>Recent versions of SWI-Prolog support so-called dictionaries of the
form <code>Tag{Key1:Value1, Key2:Value2, ...}</code>. The tag is
typically an atom (but can be a variable, as well), the keys are unique
atom or integers; the values can be anything. Suppose we have a Prolog
predicate that does something with dicts, and we would like to query it
from R. The simplest solution is a wrapper in Prolog that translates
<em>key</em>-<em>value</em> pairs
<code>[Key1-Value1, Key2-Value2, ...]</code> back and forth to
dicts:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>do_something_with_pairs(<span class="dt">Pairs0</span><span class="kw">,</span> <span class="dt">Pairs1</span>) <span class="kw">:-</span></span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>    dict_pairs(<span class="dt">Dict0</span><span class="kw">,</span> my_dict<span class="kw">,</span> <span class="dt">Pairs0</span>)<span class="kw">,</span></span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>    do_something_with_dicts(<span class="dt">Dict0</span><span class="kw">,</span> <span class="dt">Dict1</span>)<span class="kw">,</span></span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a>    dict_pairs(<span class="dt">Dict1</span><span class="kw">,</span> my_dict<span class="kw">,</span> <span class="dt">Pairs1</span>)<span class="kw">.</span></span></code></pre></div>
<p><code>do_something_with_pairs/2</code> can then be queried from R
using, for example, lists with named elements (see Table 1).</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="fu">once</span>(<span class="fu">call</span>(<span class="st">&quot;do_something_with_pairs&quot;</span>, <span class="fu">list</span>(<span class="at">a=</span><span class="dv">1</span>, <span class="at">b=</span><span class="dv">2</span>), <span class="fu">expression</span>(X)))</span></code></pre></div>
<p>In the code above, <code>dict_pairs/2</code> takes the role of both
<code>preproc/2</code> and <code>postproc/2</code> in Figure 1. It
illustrates that complicated syntax on the R side can be much simplified
when doing the conversion at the Prolog end. Ways to extend Prolog by
add-ons (“packs”) are shown in the next section.</p>
</div>
</div>
<div id="examples-and-use-cases" class="section level1">
<h1>4. Examples and use cases</h1>
<p>In this section we present a few usage examples for package
<code>rolog</code> in increasing complexity. Although the code snippets
are mostly self-explanatory, some familiarity with the Prolog language
is helpful.</p>
<div id="hello-world" class="section level2">
<h2>Hello, world</h2>
<p>Prolog’s typical <em>hello world</em> example is a search through a
directed acyclic graph (DAG), for example, a family tree like the one
given in Listing 2.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a>parent(pam<span class="kw">,</span> bob)<span class="kw">.</span> parent(bob<span class="kw">,</span> ann)<span class="kw">.</span> parent(bob<span class="kw">,</span> pat)<span class="kw">.</span> parent(pat<span class="kw">,</span> jim)<span class="kw">.</span></span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>ancestor(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Z</span>) <span class="kw">:-</span></span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a>    parent(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Z</span>)<span class="kw">.</span></span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a>ancestor(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Z</span>) <span class="kw">:-</span></span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a>    parent(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>)<span class="kw">,</span></span>
<span id="cb10-8"><a href="#cb10-8" tabindex="-1"></a>    ancestor(<span class="dt">Y</span><span class="kw">,</span> <span class="dt">Z</span>)<span class="kw">.</span></span></code></pre></div>
<dl>
<dt>Listing 2</dt>
<dd>
A family tree in Prolog (see also family.pl)
</dd>
</dl>
<p>Listing 2 is included in the package and is accessed using the
function <code>system.file</code>. Within Prolog, the normal workflow is
to consult the code with <code>[family]</code> and then to raise queries
such as <code>ancestor(X, jim)</code>, which returns, one by one, four
solutions for the variable <em>X</em>. In R, we obtain the following
results:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="fu">library</span>(rolog)</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a><span class="fu">consult</span>(<span class="fu">system.file</span>(<span class="fu">file.path</span>(<span class="st">&quot;pl&quot;</span>, <span class="st">&quot;family.pl&quot;</span>), <span class="at">package=</span><span class="st">&quot;rolog&quot;</span>))</span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a><span class="fu">query</span>(<span class="fu">call</span>(<span class="st">&quot;ancestor&quot;</span>, <span class="fu">expression</span>(X), <span class="fu">quote</span>(jim)))</span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a><span class="co">#&gt; attr(,&quot;query&quot;)</span></span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a><span class="co">#&gt; [1] &quot;ancestor(X, jim)&quot;</span></span>
<span id="cb11-7"><a href="#cb11-7" tabindex="-1"></a><span class="fu">submit</span>()        <span class="co"># solutions for X</span></span>
<span id="cb11-8"><a href="#cb11-8" tabindex="-1"></a><span class="co">#&gt; $X</span></span>
<span id="cb11-9"><a href="#cb11-9" tabindex="-1"></a><span class="co">#&gt; pat</span></span>
<span id="cb11-10"><a href="#cb11-10" tabindex="-1"></a><span class="fu">submit</span>()        <span class="co"># etc.</span></span>
<span id="cb11-11"><a href="#cb11-11" tabindex="-1"></a><span class="co">#&gt; $X</span></span>
<span id="cb11-12"><a href="#cb11-12" tabindex="-1"></a><span class="co">#&gt; pam</span></span>
<span id="cb11-13"><a href="#cb11-13" tabindex="-1"></a><span class="fu">clear</span>()         <span class="co"># close the query</span></span></code></pre></div>
<p>As stated above, <code>consult</code> loads the facts and rules of
Listing 2 into the Prolog database. <code>query</code> initializes a
query, and the subsequent calls to <code>submit</code> return the
conditions under which the query succeeds. In this example, the query
succeeds if <code>X</code> is either <code>pat</code>, <code>pam</code>,
or <code>bob</code>. A query is closed with <code>clear()</code>, or
automatically if the query fails. If we are interested in just the first
solution, we can use <code>once(Call)</code> as a shortcut to
<code>query(Call)</code>, then <code>submit()</code>, then
<code>clear()</code>. If we want to collect all solutions of a query
with a finite set of solutions, we can use
<code>findall(Call)</code>.</p>
<p>As mentioned in Section 2, a simplified syntax is provided by
<code>as.rolog</code> that accepts quoted expressions with dots
indicating Prolog variables:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a>Q <span class="ot">&lt;-</span> <span class="fu">quote</span>(<span class="fu">ancestor</span>(.X, jim))</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a><span class="fu">findall</span>(Q, <span class="at">options=</span><span class="fu">list</span>(<span class="at">preproc=</span>as.rolog))</span></code></pre></div>
</div>
<div id="backdoor-test" class="section level2">
<h2>Backdoor test</h2>
<p>A useful application of DAGs is confounder adjustment in causal
analysis <span class="citation">(Greenland, Pearl, and Robins 1999;
Barrett 2021)</span>. The Prolog file <code>backdoor.pl</code> is an
implementation of Greenland et al.’s criteria for the backdoor test for
<em>d</em>-separation in DAGs, with a predicate <code>minimal/3</code>
that searches for minimally sufficient sets of variables for confounder
adjustment on the causal path between exposure and outcome. The nodes
and arrows refer to Figure 12 in Greenland et al.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="fu">consult</span>(<span class="fu">system.file</span>(<span class="fu">file.path</span>(<span class="st">&quot;pl&quot;</span>, <span class="st">&quot;backdoor.pl&quot;</span>), <span class="at">package=</span><span class="st">&quot;rolog&quot;</span>))</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a>node <span class="ot">&lt;-</span> <span class="cf">function</span>(N) <span class="fu">invisible</span>(<span class="fu">once</span>(<span class="fu">call</span>(<span class="st">&quot;assert&quot;</span>, <span class="fu">call</span>(<span class="st">&quot;node&quot;</span>, N))))</span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a><span class="fu">node</span>(<span class="st">&quot;a&quot;</span>); <span class="fu">node</span>(<span class="st">&quot;b&quot;</span>); <span class="fu">node</span>(<span class="st">&quot;c&quot;</span>); <span class="fu">node</span>(<span class="st">&quot;f&quot;</span>); <span class="fu">node</span>(<span class="st">&quot;u&quot;</span>)</span>
<span id="cb13-5"><a href="#cb13-5" tabindex="-1"></a><span class="fu">node</span>(<span class="st">&quot;e&quot;</span>) <span class="co"># exposure</span></span>
<span id="cb13-6"><a href="#cb13-6" tabindex="-1"></a><span class="fu">node</span>(<span class="st">&quot;d&quot;</span>) <span class="co"># outcome</span></span>
<span id="cb13-7"><a href="#cb13-7" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" tabindex="-1"></a>arrow <span class="ot">&lt;-</span> <span class="cf">function</span>(X, Y) <span class="fu">invisible</span>(<span class="fu">once</span>(<span class="fu">call</span>(<span class="st">&quot;assert&quot;</span>, <span class="fu">call</span>(<span class="st">&quot;arrow&quot;</span>, X, Y))))</span>
<span id="cb13-9"><a href="#cb13-9" tabindex="-1"></a><span class="fu">arrow</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;d&quot;</span>); <span class="fu">arrow</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;f&quot;</span>); <span class="fu">arrow</span>(<span class="st">&quot;b&quot;</span>, <span class="st">&quot;d&quot;</span>); <span class="fu">arrow</span>(<span class="st">&quot;b&quot;</span>, <span class="st">&quot;f&quot;</span>)</span>
<span id="cb13-10"><a href="#cb13-10" tabindex="-1"></a><span class="fu">arrow</span>(<span class="st">&quot;c&quot;</span>, <span class="st">&quot;d&quot;</span>); <span class="fu">arrow</span>(<span class="st">&quot;c&quot;</span>, <span class="st">&quot;f&quot;</span>); <span class="fu">arrow</span>(<span class="st">&quot;e&quot;</span>, <span class="st">&quot;d&quot;</span>); <span class="fu">arrow</span>(<span class="st">&quot;f&quot;</span>, <span class="st">&quot;e&quot;</span>)</span>
<span id="cb13-11"><a href="#cb13-11" tabindex="-1"></a><span class="fu">arrow</span>(<span class="st">&quot;u&quot;</span>, <span class="st">&quot;a&quot;</span>); <span class="fu">arrow</span>(<span class="st">&quot;u&quot;</span>, <span class="st">&quot;b&quot;</span>); <span class="fu">arrow</span>(<span class="st">&quot;u&quot;</span>, <span class="st">&quot;c&quot;</span>)</span>
<span id="cb13-12"><a href="#cb13-12" tabindex="-1"></a></span>
<span id="cb13-13"><a href="#cb13-13" tabindex="-1"></a>R <span class="ot">&lt;-</span> <span class="fu">findall</span>(<span class="fu">call</span>(<span class="st">&quot;minimal&quot;</span>, <span class="st">&quot;e&quot;</span>, <span class="st">&quot;d&quot;</span>, <span class="fu">expression</span>(S)))</span>
<span id="cb13-14"><a href="#cb13-14" tabindex="-1"></a><span class="fu">unlist</span>(R)</span>
<span id="cb13-15"><a href="#cb13-15" tabindex="-1"></a><span class="co">#&gt;  S1  S2  S3   S </span></span>
<span id="cb13-16"><a href="#cb13-16" tabindex="-1"></a><span class="co">#&gt; &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;f&quot;</span></span></code></pre></div>
<p>The query to <code>minimal/3</code> returns two minimally sufficient
sets of covariates for confounder adjustment (namely, {a, b, c} and
{f}).</p>
</div>
<div id="definite-clause-grammars" class="section level2">
<h2>Definite clause grammars</h2>
<p>One of the main driving forces of Prolog development was natural
language processing <span class="citation">(Dahl 1981)</span>.
Therefore, the next example is an illustration of sentence parsing using
so-called definite clause grammars. As Listing 3 shows, rolog can access
modules from SWI’s standard library (e.g., “dcg/basics.pl”).</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="kw">:-</span> use_module(library(dcg<span class="fu">/</span>basics))<span class="kw">.</span></span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a>s(s(<span class="dt">NP</span><span class="kw">,</span> <span class="dt">VP</span>)) <span class="kw">--&gt;</span> np(<span class="dt">NP</span><span class="kw">,</span> <span class="dt">C</span>)<span class="kw">,</span> blank<span class="kw">,</span> vp(<span class="dt">VP</span><span class="kw">,</span> <span class="dt">C</span>)<span class="kw">.</span></span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a>np(<span class="dt">NP</span><span class="kw">,</span> <span class="dt">C</span>) <span class="kw">--&gt;</span> pn(<span class="dt">NP</span><span class="kw">,</span> <span class="dt">C</span>)<span class="kw">.</span></span>
<span id="cb14-5"><a href="#cb14-5" tabindex="-1"></a>np(np(<span class="dt">Det</span><span class="kw">,</span> <span class="dt">N</span>)<span class="kw">,</span> <span class="dt">C</span>) <span class="kw">--&gt;</span> det(<span class="dt">Det</span><span class="kw">,</span> <span class="dt">C</span>)<span class="kw">,</span> blank<span class="kw">,</span> n(<span class="dt">N</span><span class="kw">,</span> <span class="dt">C</span>)<span class="kw">.</span></span>
<span id="cb14-6"><a href="#cb14-6" tabindex="-1"></a>np(np(<span class="dt">Det</span><span class="kw">,</span> <span class="dt">N</span><span class="kw">,</span> <span class="dt">PP</span>)<span class="kw">,</span> <span class="dt">C</span>) <span class="kw">--&gt;</span> det(<span class="dt">Det</span><span class="kw">,</span> <span class="dt">C</span>)<span class="kw">,</span> blank<span class="kw">,</span> n(<span class="dt">N</span><span class="kw">,</span> <span class="dt">C</span>)<span class="kw">,</span> blank<span class="kw">,</span> pp(<span class="dt">PP</span>)<span class="kw">.</span></span>
<span id="cb14-7"><a href="#cb14-7" tabindex="-1"></a>vp(vp(<span class="dt">V</span><span class="kw">,</span> <span class="dt">NP</span>)<span class="kw">,</span> <span class="dt">C</span>) <span class="kw">--&gt;</span> v(<span class="dt">V</span><span class="kw">,</span> <span class="dt">C</span>)<span class="kw">,</span> blank<span class="kw">,</span> np(<span class="dt">NP</span><span class="kw">,</span> <span class="dt">_</span>)<span class="kw">.</span></span>
<span id="cb14-8"><a href="#cb14-8" tabindex="-1"></a>vp(vp(<span class="dt">V</span><span class="kw">,</span> <span class="dt">NP</span><span class="kw">,</span> <span class="dt">PP</span>)<span class="kw">,</span> <span class="dt">C</span>) <span class="kw">--&gt;</span> v(<span class="dt">V</span><span class="kw">,</span> <span class="dt">C</span>)<span class="kw">,</span> blank<span class="kw">,</span> np(<span class="dt">NP</span><span class="kw">,</span> <span class="dt">_</span>)<span class="kw">,</span> blank<span class="kw">,</span> pp(<span class="dt">PP</span>)<span class="kw">.</span></span>
<span id="cb14-9"><a href="#cb14-9" tabindex="-1"></a>pp(pp(<span class="dt">P</span><span class="kw">,</span> <span class="dt">NP</span>)) <span class="kw">--&gt;</span> p(<span class="dt">P</span>)<span class="kw">,</span> blank<span class="kw">,</span> np(<span class="dt">NP</span><span class="kw">,</span> <span class="dt">_</span>)<span class="kw">.</span></span>
<span id="cb14-10"><a href="#cb14-10" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" tabindex="-1"></a>det(det(a)<span class="kw">,</span> sg) <span class="kw">--&gt;</span> <span class="st">`</span><span class="er">a</span><span class="st">`</span><span class="kw">.</span></span>
<span id="cb14-12"><a href="#cb14-12" tabindex="-1"></a>det(det(the)<span class="kw">,</span> <span class="dt">_</span>) <span class="kw">--&gt;</span> <span class="st">`</span><span class="er">the</span><span class="st">`</span><span class="kw">.</span></span>
<span id="cb14-13"><a href="#cb14-13" tabindex="-1"></a>pn(pn(john)<span class="kw">,</span> sg) <span class="kw">--&gt;</span> <span class="st">`</span><span class="er">john</span><span class="st">`</span><span class="kw">.</span></span>
<span id="cb14-14"><a href="#cb14-14" tabindex="-1"></a>n(n(man)<span class="kw">,</span> sg) <span class="kw">--&gt;</span> <span class="st">`</span><span class="er">man</span><span class="st">`</span><span class="kw">.</span></span>
<span id="cb14-15"><a href="#cb14-15" tabindex="-1"></a>n(n(men)<span class="kw">,</span> pl) <span class="kw">--&gt;</span> <span class="st">`</span><span class="er">men</span><span class="st">`</span><span class="kw">.</span></span>
<span id="cb14-16"><a href="#cb14-16" tabindex="-1"></a>n(n(telescope)<span class="kw">,</span> sg) <span class="kw">--&gt;</span> <span class="st">`</span><span class="er">telescope</span><span class="st">`</span><span class="kw">.</span></span>
<span id="cb14-17"><a href="#cb14-17" tabindex="-1"></a>v(v(sees)<span class="kw">,</span> sg) <span class="kw">--&gt;</span> <span class="st">`</span><span class="er">sees</span><span class="st">`</span><span class="kw">.</span></span>
<span id="cb14-18"><a href="#cb14-18" tabindex="-1"></a>v(v(see)<span class="kw">,</span> pl) <span class="kw">--&gt;</span> <span class="st">`</span><span class="er">see</span><span class="st">`</span><span class="kw">.</span></span>
<span id="cb14-19"><a href="#cb14-19" tabindex="-1"></a>p(p(with)) <span class="kw">--&gt;</span> <span class="st">`</span><span class="er">with</span><span class="st">`</span><span class="kw">.</span></span>
<span id="cb14-20"><a href="#cb14-20" tabindex="-1"></a></span>
<span id="cb14-21"><a href="#cb14-21" tabindex="-1"></a><span class="co">% Translate R string to code points and invoke phrase/2</span></span>
<span id="cb14-22"><a href="#cb14-22" tabindex="-1"></a>sentence(<span class="dt">Tree</span><span class="kw">,</span> <span class="dt">Sentence</span>) <span class="kw">:-</span></span>
<span id="cb14-23"><a href="#cb14-23" tabindex="-1"></a>    string_codes(<span class="dt">Sentence</span><span class="kw">,</span> <span class="dt">Codes</span>)<span class="kw">,</span></span>
<span id="cb14-24"><a href="#cb14-24" tabindex="-1"></a>    <span class="kw">phrase</span>(s(<span class="dt">Tree</span>)<span class="kw">,</span> <span class="dt">Codes</span>)<span class="kw">.</span></span></code></pre></div>
<dl>
<dt>Listing 3</dt>
<dd>
Simple grammar and lexicon. <code>sentence/2</code> preprocesses the R
call.
</dd>
</dl>
<p>As in the first example, we first consult a little Prolog program
with a minimalistic grammar and lexicon (Listing 3, see also
<code>pl/telescope.pl</code>), and then raise a query asking for the
syntactic structure of “john sees a man with a telescope”. Closer
inspection of the two results reveals the two possible meanings, “john
sees a man <em>who carries</em> a telescope” versus “john sees a man
<em>through</em> a telescope”. Further Prolog examples of natural
language processing are found in , including the resolution of anaphoric
references and the extraction of semantic meaning.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="fu">consult</span>(<span class="fu">system.file</span>(<span class="fu">file.path</span>(<span class="st">&quot;pl&quot;</span>, <span class="st">&quot;telescope.pl&quot;</span>), <span class="at">package=</span><span class="st">&quot;rolog&quot;</span>))</span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>Q <span class="ot">&lt;-</span> <span class="fu">quote</span>(<span class="fu">sentence</span>(.Tree, <span class="st">&quot;john sees a man with a telescope&quot;</span>))</span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a><span class="fu">unlist</span>(<span class="fu">findall</span>(Q, <span class="at">options=</span><span class="fu">list</span>(<span class="at">preproc=</span>as.rolog)))</span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a><span class="co">#&gt; $Tree</span></span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a><span class="co">#&gt; s(pn(john), vp(v(sees), np(det(a), n(man), pp(p(with), np(det(a), </span></span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a><span class="co">#&gt;     n(telescope))))))</span></span>
<span id="cb15-7"><a href="#cb15-7" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb15-8"><a href="#cb15-8" tabindex="-1"></a><span class="co">#&gt; $Tree</span></span>
<span id="cb15-9"><a href="#cb15-9" tabindex="-1"></a><span class="co">#&gt; s(pn(john), vp(v(sees), np(det(a), n(man)), pp(p(with), np(det(a), </span></span>
<span id="cb15-10"><a href="#cb15-10" tabindex="-1"></a><span class="co">#&gt;     n(telescope)))))</span></span></code></pre></div>
</div>
<div id="installation-of-add-ons-for-prolog" class="section level2">
<h2>Installation of add-ons for Prolog</h2>
<p>In description of the previous example, we noted in passing that
<code>rolog</code> can access the built-in libraries of SWI-Prolog
(e.g., by calls to <code>use_module/1</code>). It is also possible to
extend the installation by add-ons, including add-ons that require
compilation, if the build tools (essentially, RTools under Windows, and
xcode under macOS) are properly configured. This is illustrated below by
the demo add-on <code>environ</code> <span class="citation">(Wielemaker
2012)</span> that collects the current environment variables.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a><span class="fu">once</span>(<span class="fu">call</span>(<span class="st">&quot;pack_install&quot;</span>, <span class="fu">quote</span>(environ), <span class="fu">list</span>(<span class="fu">quote</span>(<span class="fu">interactive</span>(<span class="cn">FALSE</span>)))))</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a><span class="fu">once</span>(<span class="fu">quote</span>(<span class="fu">use_module</span>(<span class="fu">library</span>(environ))))</span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a><span class="fu">once</span>(<span class="fu">call</span>(<span class="st">&quot;environ&quot;</span>, <span class="fu">expression</span>(X)))</span></code></pre></div>
<p>The query then unifies <em>X</em> with a list with
<code>Key=Value</code> terms. The purpose of this example is obviously
not to mimic the built-in function <code>Sys.getenv()</code> from R, but
to illustrate the installation and usage of Prolog extensions from
within R. In most situations, the user would install the pack from
within Prolog with <code>pack_install(environ).</code>.</p>
</div>
<div id="term-manipulation" class="section level2">
<h2>Term manipulation</h2>
<p>Prolog is homoiconic, that is, code is data. In this example, we make
use of Prolog’s ability to match expressions against given patterns and
modify these expressions according to a few predefined “buggy rules”
<span class="citation">(Brown and Burton 1978)</span>, inspired by
recurrent mistakes in the statistics exams of our students. Consider the
<span class="math inline">\(t\)</span>-statistic for comparing an
observed group average to a population mean:</p>
<p><span class="math display">\[
T = \frac{\overline{X} - \mu}{s / \sqrt{N}}
\]</span></p>
<p>Some mistakes may occur in this calculation, for example, omission of
the implicit parentheses around the numerator and the denominator when
typing the numbers into a calculator, resulting in <span class="math inline">\(\overline{X} - \frac{\mu}{s} \div
\sqrt{N}\)</span>, or forgetting the square root around <span class="math inline">\(N\)</span>, or both. Prolog code for the two buggy
rules is given in Listing 4.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a><span class="co">% Correct steps and mistakes</span></span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a>expert(tratio(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Mu</span><span class="kw">,</span> <span class="dt">S</span><span class="kw">,</span> <span class="dt">N</span>)<span class="kw">,</span> frac(<span class="dt">X</span> <span class="fu">-</span> <span class="dt">Mu</span><span class="kw">,</span> <span class="dt">S</span> <span class="fu">/</span> sqrt(<span class="dt">N</span>)))<span class="kw">.</span></span>
<span id="cb17-3"><a href="#cb17-3" tabindex="-1"></a>buggy(frac(<span class="dt">X</span> <span class="fu">-</span> <span class="dt">Mu</span><span class="kw">,</span> <span class="dt">S</span> <span class="fu">/</span> <span class="dt">SQRTN</span>)<span class="kw">,</span> <span class="dt">X</span> <span class="fu">-</span> frac(<span class="dt">Mu</span><span class="kw">,</span> <span class="dt">S</span>) <span class="fu">/</span> <span class="dt">SQRTN</span>)<span class="kw">.</span></span>
<span id="cb17-4"><a href="#cb17-4" tabindex="-1"></a>buggy(sqrt(<span class="dt">N</span>)<span class="kw">,</span> <span class="dt">N</span>)<span class="kw">.</span></span>
<span id="cb17-5"><a href="#cb17-5" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" tabindex="-1"></a><span class="co">% Apply expert and buggy rules, or enter expressions</span></span>
<span id="cb17-7"><a href="#cb17-7" tabindex="-1"></a>step(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>) <span class="kw">:-</span></span>
<span id="cb17-8"><a href="#cb17-8" tabindex="-1"></a>    expert(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>) <span class="kw">;</span> buggy(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>)<span class="kw">.</span></span>
<span id="cb17-9"><a href="#cb17-9" tabindex="-1"></a>step(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>) <span class="kw">:-</span></span>
<span id="cb17-10"><a href="#cb17-10" tabindex="-1"></a>    <span class="dt">compound</span>(<span class="dt">X</span>)<span class="kw">,</span></span>
<span id="cb17-11"><a href="#cb17-11" tabindex="-1"></a>    mapargs(search<span class="kw">,</span> <span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>)<span class="kw">,</span></span>
<span id="cb17-12"><a href="#cb17-12" tabindex="-1"></a>    dif(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>)<span class="kw">.</span></span>
<span id="cb17-13"><a href="#cb17-13" tabindex="-1"></a></span>
<span id="cb17-14"><a href="#cb17-14" tabindex="-1"></a><span class="co">% Search through problem space</span></span>
<span id="cb17-15"><a href="#cb17-15" tabindex="-1"></a>search(<span class="dt">X</span><span class="kw">,</span> <span class="dt">X</span>)<span class="kw">.</span></span>
<span id="cb17-16"><a href="#cb17-16" tabindex="-1"></a>search(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Z</span>) <span class="kw">:-</span></span>
<span id="cb17-17"><a href="#cb17-17" tabindex="-1"></a>    step(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>)<span class="kw">,</span></span>
<span id="cb17-18"><a href="#cb17-18" tabindex="-1"></a>    search(<span class="dt">Y</span><span class="kw">,</span> <span class="dt">Z</span>)<span class="kw">.</span></span></code></pre></div>
<dl>
<dt>Listing 4</dt>
<dd>
Manipulating terms in Prolog
</dd>
</dl>
<p>The little e-learning system shown in Listing 4 produces six response
alternatives. The fourth and the sixth result are combinations of the
same two buggy rules (parenthesis, then square root, and the other way
round). Some additional filters would be needed to eliminate trivial and
redundant solutions .</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a><span class="fu">consult</span>(<span class="fu">system.file</span>(<span class="fu">file.path</span>(<span class="st">&quot;pl&quot;</span>, <span class="st">&quot;buggy.pl&quot;</span>), <span class="at">package=</span><span class="st">&quot;rolog&quot;</span>))</span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a>Q <span class="ot">&lt;-</span> <span class="fu">quote</span>(<span class="fu">search</span>(<span class="fu">tratio</span>(x, mu, s, n), .S))</span>
<span id="cb18-3"><a href="#cb18-3" tabindex="-1"></a><span class="fu">unlist</span>(<span class="fu">findall</span>(Q, <span class="at">options=</span><span class="fu">list</span>(<span class="at">preproc=</span>as.rolog)))</span>
<span id="cb18-4"><a href="#cb18-4" tabindex="-1"></a><span class="co">#&gt; $S</span></span>
<span id="cb18-5"><a href="#cb18-5" tabindex="-1"></a><span class="co">#&gt; tratio(x, mu, s, n)</span></span>
<span id="cb18-6"><a href="#cb18-6" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb18-7"><a href="#cb18-7" tabindex="-1"></a><span class="co">#&gt; $S</span></span>
<span id="cb18-8"><a href="#cb18-8" tabindex="-1"></a><span class="co">#&gt; frac(x - mu, s/sqrt(n))</span></span>
<span id="cb18-9"><a href="#cb18-9" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb18-10"><a href="#cb18-10" tabindex="-1"></a><span class="co">#&gt; $S</span></span>
<span id="cb18-11"><a href="#cb18-11" tabindex="-1"></a><span class="co">#&gt; x - frac(mu, s)/sqrt(n)</span></span>
<span id="cb18-12"><a href="#cb18-12" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb18-13"><a href="#cb18-13" tabindex="-1"></a><span class="co">#&gt; $S</span></span>
<span id="cb18-14"><a href="#cb18-14" tabindex="-1"></a><span class="co">#&gt; x - frac(mu, s)/n</span></span>
<span id="cb18-15"><a href="#cb18-15" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb18-16"><a href="#cb18-16" tabindex="-1"></a><span class="co">#&gt; $S</span></span>
<span id="cb18-17"><a href="#cb18-17" tabindex="-1"></a><span class="co">#&gt; frac(x - mu, s/n)</span></span>
<span id="cb18-18"><a href="#cb18-18" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb18-19"><a href="#cb18-19" tabindex="-1"></a><span class="co">#&gt; $S</span></span>
<span id="cb18-20"><a href="#cb18-20" tabindex="-1"></a><span class="co">#&gt; x - frac(mu, s)/n</span></span></code></pre></div>
<p>An important feature of such a term manipulation is that the
evaluation of the term can be postponed; for example, there is no need
to instantiate the variables <em>x</em>, <em>mu</em>, <em>s</em>, and
<em>n</em> with given values before raising a query. This is especially
helpful for variables that may represent larger sets of data in later
steps.</p>
<p>It should be mentioned that R is homoiconic, too, and the Prolog code
above can, in principle, be rewritten in R using non-standard evaluation
techniques <span class="citation">(Wickham 2019)</span>. Prolog’s
inbuilt pattern matching algorithm simplifies things a lot, though.</p>
</div>
<div id="rendering-mathematical-expressions" class="section level2">
<h2>Rendering mathematical expressions</h2>
<p>The R extension of the markdown language <span class="citation">(Xie,
Dervieux, and Riederer 2020)</span> enables reproducible statistical
reports with nice typesetting in HTML, Microsoft Word, and Latex.
However, so far, R expressions such as <code>pbinom(k, N, p)</code> are
typeset as-is; prettier mathematical expressions such as <span class="math inline">\(P_\mathrm{Bi}(X \le k; N, p)\)</span> require
Latex commands like
<code>P_\mathrm{Bi}\left(X \le k; N, p\right)</code>, which are
cumbersome to type in and hard to read even if the expressions are
simple. Since recently, manual pages include support for mathematical
expressions <span class="citation">(Sarkar and Hornik 2022)</span>,
which already is a big improvement.</p>
<p>Below Prolog’s grammar rules are used for an <em>automatic</em>
translation of R calls to MathML. The result can then be used for
calculations or it can be rendered on a web page. A limited set of rules
for translation from R to MathML is found in <code>pl/mathml.pl</code>
of package <code>rolog</code>. A more comprehensive translator is
provided by the R package <code>mathml</code> <span class="citation">(Gondan 2022)</span>. The relevant code snippets are
shown in the listings below, along with their output.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a><span class="fu">library</span>(rolog)</span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a><span class="fu">consult</span>(<span class="fu">system.file</span>(<span class="fu">file.path</span>(<span class="st">&quot;pl&quot;</span>, <span class="st">&quot;mathml.pl&quot;</span>), <span class="at">package=</span><span class="st">&quot;rolog&quot;</span>))</span>
<span id="cb19-3"><a href="#cb19-3" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" tabindex="-1"></a><span class="co"># R interface to Prolog predicate r2mathml/2</span></span>
<span id="cb19-5"><a href="#cb19-5" tabindex="-1"></a>mathml <span class="ot">&lt;-</span> <span class="cf">function</span>(term)</span>
<span id="cb19-6"><a href="#cb19-6" tabindex="-1"></a>{</span>
<span id="cb19-7"><a href="#cb19-7" tabindex="-1"></a>  t <span class="ot">&lt;-</span> <span class="fu">once</span>(<span class="fu">call</span>(<span class="st">&quot;r2mathml&quot;</span>, term, <span class="fu">expression</span>(X)))</span>
<span id="cb19-8"><a href="#cb19-8" tabindex="-1"></a>  <span class="fu">cat</span>(<span class="fu">paste</span>(t<span class="sc">$</span>X, <span class="at">collapse=</span><span class="st">&quot;&quot;</span>))</span>
<span id="cb19-9"><a href="#cb19-9" tabindex="-1"></a>}</span></code></pre></div>
<dl>
<dt>Listing 4</dt>
<dd>
Generate MathML from R expressions
</dd>
</dl>
<p>The first example is easy. At the Prolog end, there is a handler for
<code>pbinom/3</code> that translates the term into a pretty MathML
syntax like P_bi(X &lt;= k; N, pi).</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a>term <span class="ot">&lt;-</span> <span class="fu">quote</span>(<span class="fu">pbinom</span>(k, N, p))</span>
<span id="cb20-2"><a href="#cb20-2" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" tabindex="-1"></a><span class="co"># Pretty print</span></span>
<span id="cb20-4"><a href="#cb20-4" tabindex="-1"></a><span class="fu">mathml</span>(term)</span></code></pre></div>
<p><math><mrow><msub><mi>P</mi><mtext>Bi</mtext></msub><mo>⁡</mo><mrow><mo>(</mo><mrow><mrow><mi>X</mi><mo>≤</mo><mi>k</mi></mrow><mo>;</mo><mrow><mi>N</mi><mo>,</mo><mi>p</mi></mrow></mrow><mo>)</mo></mrow></mrow></math></p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a></span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a><span class="co"># Do some calculations with the same term</span></span>
<span id="cb21-3"><a href="#cb21-3" tabindex="-1"></a>k <span class="ot">&lt;-</span> <span class="dv">10</span></span>
<span id="cb21-4"><a href="#cb21-4" tabindex="-1"></a>N <span class="ot">&lt;-</span> <span class="dv">22</span></span>
<span id="cb21-5"><a href="#cb21-5" tabindex="-1"></a>p <span class="ot">&lt;-</span> <span class="fl">0.4</span></span>
<span id="cb21-6"><a href="#cb21-6" tabindex="-1"></a><span class="fu">eval</span>(term)</span></code></pre></div>
<p>[1] 0.77195</p>
<p>The next example is interesting because Prolog needs to find out the
name of the integration variable for <code>sin</code>. For that purpose,
rolog provides a predicate <code>r_eval/2</code> that calls R from
Prolog (i.e., the reverse direction, see also next example). Here, the
predicate is used for the R function <code>formalArgs(args(sin))</code>,
which returns the name of the function argument of <code>sin</code>,
that is, <code>x</code>.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a>term <span class="ot">&lt;-</span> <span class="fu">quote</span>(<span class="fu">integrate</span>(sin, <span class="dv">0</span><span class="dt">L</span>, <span class="dv">2</span><span class="dt">L</span><span class="sc">*</span>pi))</span>
<span id="cb22-2"><a href="#cb22-2" tabindex="-1"></a><span class="fu">mathml</span>(term)</span></code></pre></div>
<p><math><mrow><munderover><mo>∫</mo><mn>0</mn><mrow><mn>2</mn><mo>⁢</mo><mi>π</mi></mrow></munderover><mrow><mi>sin</mi><mo>⁡</mo><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow><mspace width="thinmathspace"></mspace><mi>d</mi><mi>x</mi></mrow></math></p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a><span class="fu">eval</span>(term)</span></code></pre></div>
<p>2.221501e-16 with absolute error &lt; 4.4e-14</p>
<p>Note that the Prolog end, the handler for <code>integrate/3</code> is
rather rigid; it accepts only these three arguments in that particular
order, and without names, that is,
<code>integrate(sin, lower=0L, upper=2L * pi)</code> would not print the
desired result.</p>
<p>The extra R function <code>canonical()</code> applies
<code>match.call()</code> to non-primitive R calls, basically cleaning
up the arguments and bringing them into the correct order. Moreover, an
extra handler maps the extractor function <code>$(Fn, &quot;value&quot;)</code> to
<code>Fn</code>.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" tabindex="-1"></a>canonical <span class="ot">&lt;-</span> <span class="cf">function</span>(term)</span>
<span id="cb24-2"><a href="#cb24-2" tabindex="-1"></a>{</span>
<span id="cb24-3"><a href="#cb24-3" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">is.call</span>(term))</span>
<span id="cb24-4"><a href="#cb24-4" tabindex="-1"></a>  {</span>
<span id="cb24-5"><a href="#cb24-5" tabindex="-1"></a>    f <span class="ot">&lt;-</span> <span class="fu">match.fun</span>(term[[<span class="dv">1</span>]])</span>
<span id="cb24-6"><a href="#cb24-6" tabindex="-1"></a>    <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is.primitive</span>(f))</span>
<span id="cb24-7"><a href="#cb24-7" tabindex="-1"></a>      term <span class="ot">&lt;-</span> <span class="fu">match.call</span>(f, term)</span>
<span id="cb24-8"><a href="#cb24-8" tabindex="-1"></a>    </span>
<span id="cb24-9"><a href="#cb24-9" tabindex="-1"></a>    <span class="co"># Recurse into arguments</span></span>
<span id="cb24-10"><a href="#cb24-10" tabindex="-1"></a>    term[<span class="sc">-</span><span class="dv">1</span>] <span class="ot">&lt;-</span> <span class="fu">lapply</span>(term[<span class="sc">-</span><span class="dv">1</span>], canonical)</span>
<span id="cb24-11"><a href="#cb24-11" tabindex="-1"></a>  }</span>
<span id="cb24-12"><a href="#cb24-12" tabindex="-1"></a></span>
<span id="cb24-13"><a href="#cb24-13" tabindex="-1"></a>  <span class="fu">return</span>(term)</span>
<span id="cb24-14"><a href="#cb24-14" tabindex="-1"></a>}</span>
<span id="cb24-15"><a href="#cb24-15" tabindex="-1"></a></span>
<span id="cb24-16"><a href="#cb24-16" tabindex="-1"></a>g <span class="ot">&lt;-</span> <span class="cf">function</span>(u)</span>
<span id="cb24-17"><a href="#cb24-17" tabindex="-1"></a>  <span class="fu">sin</span>(u)</span>
<span id="cb24-18"><a href="#cb24-18" tabindex="-1"></a></span>
<span id="cb24-19"><a href="#cb24-19" tabindex="-1"></a><span class="co"># Mixture of (partially) named and positional arguments in unusual order</span></span>
<span id="cb24-20"><a href="#cb24-20" tabindex="-1"></a>term <span class="ot">&lt;-</span> <span class="fu">quote</span>(<span class="dv">2</span><span class="dt">L</span> <span class="sc">*</span> <span class="fu">integrate</span>(<span class="at">low=</span><span class="sc">-</span><span class="cn">Inf</span>, <span class="at">up=</span><span class="cn">Inf</span>, g)<span class="sc">$</span>value)</span>
<span id="cb24-21"><a href="#cb24-21" tabindex="-1"></a><span class="fu">mathml</span>(<span class="fu">canonical</span>(term))</span></code></pre></div>
<p><math><mrow><mn>2</mn><mo>⋅</mo><mrow><munderover><mo>∫</mo><mrow><mo>-</mo><mi>∞</mi></mrow><mi>∞</mi></munderover><mrow><mi>g</mi><mo>⁡</mo><mrow><mo>(</mo><mi>u</mi><mo>)</mo></mrow></mrow><mspace width="thinmathspace"></mspace><mi>d</mi><mi>u</mi></mrow></mrow></math></p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a></span>
<span id="cb25-2"><a href="#cb25-2" tabindex="-1"></a><span class="co"># It is a bit of a mystery that R knows the result of this integral.</span></span>
<span id="cb25-3"><a href="#cb25-3" tabindex="-1"></a><span class="fu">eval</span>(term)</span></code></pre></div>
<p>[1] 0</p>
<p>Note that both <code>sin</code> nor <code>g</code> in the above terms
are R symbols, not R functions. In order to render something like
<code>call(&quot;integrate&quot;, low=-Inf, up=Inf, g)</code>, or
<code>call(&quot;integrate&quot;, low=-Inf, up=Inf, sin)</code>, with
<code>g</code> and <code>sin</code> referring to the respective
functions, one would need to determine its name, which is not possible
in general.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" tabindex="-1"></a><span class="fu">print</span>(g)</span>
<span id="cb26-2"><a href="#cb26-2" tabindex="-1"></a><span class="co">#&gt; function (u) </span></span>
<span id="cb26-3"><a href="#cb26-3" tabindex="-1"></a><span class="co">#&gt; sin(u)</span></span>
<span id="cb26-4"><a href="#cb26-4" tabindex="-1"></a><span class="co">#&gt; &lt;bytecode: 0x565387dd7398&gt;</span></span></code></pre></div>
</div>
<div id="calling-r-from-prolog" class="section level2">
<h2>Calling R from Prolog</h2>
<p>The basic workflow of the bridge from R to Prolog is to (A) translate
an R expression into a Prolog term (i.e., a predicate), (B) query the
predicate, and then, (C) translate the result (i.e., the bindings of the
variables) back to R (see also Figure 1). The reverse direction is
straightforward, we start by translating a Prolog term to an
R expression (i.e. Step C), evaluate the R expression, and then
translate the result back to a Prolog term (Step A). Package
<code>rolog</code> provides two predicates for that purpose,
<code>r_eval(Expr)</code> and <code>r_eval(Expr, Res)</code>. The former
is used to invoke an R expression <code>Expr</code> for its side effects
(e.g., initializing a random number generator); it does not return a
result. The latter is used to evaluate the R expression and return the
result <code>Res</code>. The code snippet in Listing 6
(<code>r_eval.pl</code>) illustrates this behavior.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb27-1"><a href="#cb27-1" tabindex="-1"></a>r_seed(<span class="dt">Seed</span>) <span class="kw">:-</span></span>
<span id="cb27-2"><a href="#cb27-2" tabindex="-1"></a>    r_eval(<span class="st">&#39;</span><span class="er">set</span><span class="st">.</span><span class="er">seed</span><span class="st">&#39;</span>(<span class="dt">Seed</span>))<span class="kw">.</span></span>
<span id="cb27-3"><a href="#cb27-3" tabindex="-1"></a></span>
<span id="cb27-4"><a href="#cb27-4" tabindex="-1"></a>r_norm(<span class="dt">N</span><span class="kw">,</span> <span class="dt">L</span>) <span class="kw">:-</span></span>
<span id="cb27-5"><a href="#cb27-5" tabindex="-1"></a>    r_eval(rnorm(<span class="dt">N</span>)<span class="kw">,</span> <span class="dt">L</span>)<span class="kw">.</span></span></code></pre></div>
<dl>
<dt>Listing 6</dt>
<dd>
Calling R from Prolog using <code>r_eval/1</code> and
<code>r_eval/2</code>. The R call <code>set.seed</code> is quoted
because the dot is an operator in Prolog.
</dd>
</dl>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" tabindex="-1"></a><span class="fu">consult</span>(<span class="fu">system.file</span>(<span class="fu">file.path</span>(<span class="st">&quot;pl&quot;</span>, <span class="st">&quot;r_eval.pl&quot;</span>), <span class="at">package=</span><span class="st">&quot;rolog&quot;</span>))</span>
<span id="cb28-2"><a href="#cb28-2" tabindex="-1"></a><span class="fu">invisible</span>(<span class="fu">once</span>(<span class="fu">call</span>(<span class="st">&quot;r_seed&quot;</span>, <span class="dv">123</span><span class="dt">L</span>)))</span>
<span id="cb28-3"><a href="#cb28-3" tabindex="-1"></a><span class="fu">once</span>(<span class="fu">call</span>(<span class="st">&quot;r_norm&quot;</span>, <span class="dv">3</span><span class="dt">L</span>, <span class="fu">expression</span>(X)))</span>
<span id="cb28-4"><a href="#cb28-4" tabindex="-1"></a><span class="co">#&gt; $X</span></span>
<span id="cb28-5"><a href="#cb28-5" tabindex="-1"></a><span class="co">#&gt; [1] -0.5604756 -0.2301775  1.5587083</span></span></code></pre></div>
<p>The example in Listing 6 is a bit trivial, basically illustrating the
syntax and the workflow. More serious applications of are shown in the
next two sections where <code>r_eval/2</code> is used to evaluate
monotonically behaving R functions and to obtain the names of function
arguments in R.</p>
<p>As show below, the default environment of <code>rolog</code>’s
<code>r_eval/2</code> is <code>.GlobalEnv</code>, this can be changed in
an optional argument to <code>once()</code>, <code>findall()</code>, and
<code>query()</code>.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" tabindex="-1"></a><span class="co"># Set variable in R, read in Prolog</span></span>
<span id="cb29-2"><a href="#cb29-2" tabindex="-1"></a>env <span class="ot">&lt;-</span> <span class="fu">new.env</span>()</span>
<span id="cb29-3"><a href="#cb29-3" tabindex="-1"></a><span class="fu">with</span>(env, a <span class="ot">&lt;-</span> <span class="dv">1</span>)</span>
<span id="cb29-4"><a href="#cb29-4" tabindex="-1"></a><span class="fu">once</span>(<span class="fu">call</span>(<span class="st">&quot;r_eval&quot;</span>, <span class="fu">quote</span>(a), <span class="fu">expression</span>(X)), <span class="at">env=</span>env)</span>
<span id="cb29-5"><a href="#cb29-5" tabindex="-1"></a><span class="co">#&gt; $X</span></span>
<span id="cb29-6"><a href="#cb29-6" tabindex="-1"></a><span class="co">#&gt; [1] 5</span></span>
<span id="cb29-7"><a href="#cb29-7" tabindex="-1"></a></span>
<span id="cb29-8"><a href="#cb29-8" tabindex="-1"></a><span class="co"># Set R variable in Prolog, read in R</span></span>
<span id="cb29-9"><a href="#cb29-9" tabindex="-1"></a><span class="fu">invisible</span>(<span class="fu">once</span>(<span class="fu">call</span>(<span class="st">&quot;r_eval&quot;</span>, <span class="fu">call</span>(<span class="st">&quot;&lt;-&quot;</span>, <span class="fu">quote</span>(b), <span class="dv">2</span>))))</span>
<span id="cb29-10"><a href="#cb29-10" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">&quot;b =&quot;</span>, b)</span>
<span id="cb29-11"><a href="#cb29-11" tabindex="-1"></a><span class="co">#&gt; b = 2</span></span></code></pre></div>
<p>If the R call raises an exception, an error is propagated to Prolog
and finally to the <code>rolog</code> package:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" tabindex="-1"></a><span class="co">#try(once(quote(r_eval(rnorm(-1))))) # return &quot;-1&quot; random normals</span></span></code></pre></div>
</div>
<div id="interval-arithmetic" class="section level2">
<h2>Interval arithmetic</h2>
<p>Let <span class="math inline">\(\langle\ell, u\rangle\)</span> denote
a number between <span class="math inline">\(\ell\)</span> and <span class="math inline">\(u\)</span>, <span class="math inline">\(\ell\le
u\)</span>. It is easily verified that the result of the difference
<span class="math inline">\(\langle\ell_1, u_1\rangle - \langle\ell_2,
u_2\rangle\)</span> is somewhere in the interval <span class="math inline">\(\langle \ell_1 - u_2, u_1 -
\ell_2\rangle\)</span>, and a number of rules exist for basic arithmetic
operations and (piecewise) monotonically behaving functions <span class="citation">(Hickey, Ju, and Emden 2001)</span>. For ratios,
denominators with mixed sign yield two possible intervals, for example,
<span class="math inline">\(\langle 1, 2\rangle / \langle -3, 3\rangle =
\langle -\infty, 3\rangle \cup \langle 3, \infty\rangle\)</span>, as
shown in Figure 4 in Hickey et al.’s article. The number of possible
candidates increases if more complicated functions are involved, as
unions of intervals themselves appear as arguments (e.g., if <span class="math inline">\(I_1 \cup I_2\)</span> is added to <span class="math inline">\(I_3 \cup I_4\)</span>, the result is <span class="math inline">\(I_1 + I_3 \cup I_1 + I_4 \cup I_2 + I_3 \cup I_2 +
I_4\)</span>). As a consequence, calculations in interval arithmetic are
non-deterministic in nature, and the number of possible results is not
foreseeable and cannot, in general, be vectorized as is often done in R.
Use cases for interval arithmetic are the limitations of floating-point
representations in computer hardware, but intervals can also be used to
represent the result of measurements with limited precision, or
truncated intermediate results of students doing hand calculations. A
few rules for basic interval arithmetic are found in
<code>pl/interval.pl</code>; a few examples are shown below. Again,
Prolog rings back to R via <code>r_eval/2</code> to determine the result
of <code>dbinom(X, Size, Prob, Log)</code>.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" tabindex="-1"></a><span class="co">#consult(system.file(file.path(&quot;pl&quot;, &quot;interval.pl&quot;), package=&quot;rolog&quot;))</span></span>
<span id="cb31-2"><a href="#cb31-2" tabindex="-1"></a></span>
<span id="cb31-3"><a href="#cb31-3" tabindex="-1"></a><span class="co">#Q &lt;- quote(int(`...`(1, 2) / `...`(-3, 3), .Res))</span></span>
<span id="cb31-4"><a href="#cb31-4" tabindex="-1"></a><span class="co">#unlist(findall(Q, options=list(preproc=as.rolog)))</span></span>
<span id="cb31-5"><a href="#cb31-5" tabindex="-1"></a></span>
<span id="cb31-6"><a href="#cb31-6" tabindex="-1"></a><span class="co">#D  &lt;- quote(`...`(5.7, 5.8))</span></span>
<span id="cb31-7"><a href="#cb31-7" tabindex="-1"></a><span class="co">#mu &lt;- 4</span></span>
<span id="cb31-8"><a href="#cb31-8" tabindex="-1"></a><span class="co">#s  &lt;- quote(`...`(3.8, 3.9))</span></span>
<span id="cb31-9"><a href="#cb31-9" tabindex="-1"></a><span class="co">#N  &lt;- 24L</span></span>
<span id="cb31-10"><a href="#cb31-10" tabindex="-1"></a><span class="co">#tratio &lt;- call(&quot;/&quot;, call(&quot;-&quot;, D, mu), call(&quot;/&quot;, s, call(&quot;sqrt&quot;, N)))</span></span>
<span id="cb31-11"><a href="#cb31-11" tabindex="-1"></a><span class="co">#once(call(&quot;int&quot;, tratio, expression(Res)))</span></span>
<span id="cb31-12"><a href="#cb31-12" tabindex="-1"></a></span>
<span id="cb31-13"><a href="#cb31-13" tabindex="-1"></a><span class="co"># Binomial density</span></span>
<span id="cb31-14"><a href="#cb31-14" tabindex="-1"></a><span class="co">#prob = quote(`...`(0.2, 0.3))</span></span>
<span id="cb31-15"><a href="#cb31-15" tabindex="-1"></a><span class="co">#once(call(&quot;int&quot;, call(&quot;dbinom&quot;, 4L, 10L, prob, FALSE), expression(Res)))</span></span></code></pre></div>
<p>The slightly cumbersome syntax for entering an interval <span class="math inline">\(\langle \ell, u\rangle\)</span> is due to the fact
that the ellipsis is a reserved symbol in R and cannot be used as an
infix operator. A powerful and comprehensive system for constraint logic
programming over intervals is available as a Prolog pack <span class="citation">(Workman 2021)</span> and can easily be connected to R
using, for example, the present package.</p>
</div>
</div>
<div id="conclusions" class="section level1">
<h1>5. Conclusions</h1>
<p>R has become the primary language for statistical programming and
data science, but is currently lacking support for traditional, symbolic
artificial intelligence. There are already two add-ons for SWI-Prolog
that allow to run R calculations from Prolog <span class="citation">(Angelopoulos et al. 2013; Wielemaker 2021b)</span>,
but a connection in the other direction was missing, so far.
<code>rolog</code> bridges this gap by providing an interface to a
SWI-Prolog distribution in an R package. The communication between the
two systems is mainly in the form of queries from R to Prolog, but two
predicates allow Prolog to ring back and evaluate terms in R. The design
of the package is minimalistic, providing three main functions
<code>query()</code>, <code>submit()</code>, and <code>clear()</code>,
and a very limited set of convenience tools (<code>consult()</code>,
<code>once()</code>, and <code>findall()</code>) to facilitate recurrent
everyday actions. As both systems are homoiconic in nature, it was easy
to establish a one-to-one correspondence between many of the elements of
the two languages. Most exceptions (e.g., lack of R support for empty
symbols) can be avoided and/or circumvented by wrapper functions at both
ends.</p>
<p>Simple ways to extend the package have been described in Section 2;
such extensions could, for example, include R objects and structures
like those returned by <code>lm()</code>, or S4 classes. In many use
cases, this may be realized by transforming the R object to a list with
named elements, and rebuild the object on the Prolog end on an as-needed
basis. After a query, the process is reversed. If speed is an issue,
more of these steps can, in principle, be moved into the package and
implemented in <code>Rcpp</code>.</p>
<p><code>rolog</code>, thus, opens up a wide of applications in logic
programming for statisticians and researchers at the intersection of
symbolic and connectionist artificial intelligence, where concise
knowledge representation is combined with statistical power. Moreover,
<code>rolog</code> provides starting points for useful small-scale
solutions for everyday issues in data science (term transformations,
pretty mathematical output, interval arithmetic, see Section 3).</p>
<p>At its present stage, a major limitation of <code>rolog</code> is its
relatively slow speed. For example, translation of R lists or vectors to
the respective elements of the Prolog language (also lists,
<code>#/N</code>) is done element-wise, in both directions. The
translation is optimized by using <code>Rcpp</code> <span class="citation">(Eddelbuettel and Balamuta 2018)</span>, but there
remains an upper bound in the efficiency, because Prolog does not
support vectors or matrices. Since Prolog’s primary purpose is not
vector or matrix calculation, this limitation may not show up in
real-world applications. Another issue, maybe a bit annoying, is the
rather cumbersome syntax of the interface, with the need for quoted
calls and R expressions for representing Prolog variables.
<code>rolog</code> was deliberately chosen to be minimalistic and, so
far, only depends on base R. A more concise representation might be
obtained by tools from the “Tidyverse” ecosystem, as described in
Chapter 19 of Advanced R <span class="citation">(Wickham 2019)</span>.
Finally, at this stage, <code>rolog</code> is unable to deal with cyclic
terms (e.g.,
<code>once(call(&quot;=&quot;, expression(A), call(&quot;f&quot;, expression(A))))</code>,
i.e., <code>A = f(A)</code> raises an error message).</p>
<p><code>rolog</code> is available for R Version 4.2 and later, and can
easily be installed using the usual
<code>install.packages(&quot;rolog&quot;)</code>. The source code of the package
is found at <a href="https://github.com/mgondan/rolog/" class="uri">https://github.com/mgondan/rolog/</a>, including
installation instructions for Unix, Windows and macOS.</p>
</div>
<div id="acknowledgement" class="section level1">
<h1>Acknowledgement</h1>
<p>Development of the package profited substantially from the Prolog
packs <code>rserve_client</code> <span class="citation">(Wielemaker
2021b)</span> and <code>real</code> <span class="citation">(Angelopoulos
et al. 2013)</span>.</p>
</div>
<div id="note" class="section level1">
<h1>Note</h1>
<p>The results in this paper were obtained using R 4.1.2024 with the
<code>rolog</code> 0.9.20 package. R itself and all packages used are
available from the Comprehensive R Archive Network (CRAN) at <a href="https://CRAN.R-project.org/" class="uri">https://CRAN.R-project.org/</a>.</p>
</div>
<div id="references" class="section level1 unnumbered">
<h1 class="unnumbered">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-Angelopoulos2013" class="csl-entry">
Angelopoulos, Nicos, Vitor Santos Costa, Joao Azevedo, Jan Wielemaker,
Rui Camacho, and Lodewyk Wessels. 2013. <span>“Integrative Functional
Statistics in Logic Programming.”</span> In <em>Proceedings of Practical
Aspects of Declarative Languages</em>, 7752:190–205. LNCS. Rome, Italy.
</div>
<div id="ref-Angelopoulos2008" class="csl-entry">
Angelopoulos, Nicos, and James Cussens. 2008. <span>“Bayesian Learning
of Bayesian Networks with Informative Priors.”</span> <em>Journal of
Annals of Mathematics and Artificial Intelligence</em> 54: 53–98.
</div>
<div id="ref-YapR" class="csl-entry">
Azevedo, J. 2011. <em>YapR</em>. <a href="https://github.com/jcazevedo/YapR">https://github.com/jcazevedo/YapR</a>.
</div>
<div id="ref-ggdag" class="csl-entry">
Barrett, Malcolm. 2021. <em>Ggdag: Analyze and Create Elegant Directed
Acyclic Graphs</em>. <a href="https://CRAN.R-project.org/package=ggdag">https://CRAN.R-project.org/package=ggdag</a>.
</div>
<div id="ref-Brown1978" class="csl-entry">
Brown, J. S., and R. R. Burton. 1978. <span>“Diagnostic Models for
Procedural Bugs in Basic Mathematical Skills.”</span> <em>Cognitive
Science</em> 2: 155–92.
</div>
<div id="ref-Carro2004" class="csl-entry">
Carro, Manuel. 2004. <em>An Application of Rational Trees in a Logic
Programming Interpreter for a Procedural Language</em>. Technical
University of Madrid: School of ComputerScience.
</div>
<div id="ref-Cussens2000" class="csl-entry">
Cussens, James. 2000. <span>“Stochastic Logic Programs: Sampling,
Inference and Applications.”</span> In <em>Sixteenth Annual Conference
on Uncertainty in Artificial Intelligence (UAI’00)</em>, edited by
Thomas J. Bergin Jr. and Richard G. Gibson Jr., 115–22. San Francisco,
CA: Morgan Kaufmann Publishers.
</div>
<div id="ref-Dahl1981" class="csl-entry">
Dahl, V. 1981. <span>“Translating Spanish into Logic Through
Logic.”</span> <em>American Journal of Computational Linguistics</em> 7
(3): 149–64.
</div>
<div id="ref-Edelbuettel2018" class="csl-entry">
Eddelbuettel, Dirk, and James Joseph Balamuta. 2018. <span>“<span class="nocase">Extending R with C++: A Brief Introduction to
Rcpp</span>.”</span> <em>The American Statistician</em> 72 (1): 28–36.
</div>
<div id="ref-Fruehwirth1998" class="csl-entry">
Frühwirth, T. 1998. <span>“Theory and Practice of Constraint Handling
Rules.”</span> <em>Journal of Logic Programming</em> 37: 95–138.
</div>
<div id="ref-mathml" class="csl-entry">
Gondan, Matthias. 2022. <em>Mathml: Translate r Expressions to MathML
and LaTeX/MathJax</em>.
</div>
<div id="ref-rswipl" class="csl-entry">
———. 2023. <em>Rswipl: Embed ’SWI’-’prolog’</em>. <a href="https://CRAN.R-project.org/package=rswipl">https://CRAN.R-project.org/package=rswipl</a>.
</div>
<div id="ref-greenland1999" class="csl-entry">
Greenland, S., J. Pearl, and J. M. Robins. 1999. <span>“Causal Diagrams
for Epidemiologic Research.”</span> <em>Epidemiology</em> 10: 37–48.
</div>
<div id="ref-Hickey2001" class="csl-entry">
Hickey, T., Q. Ju, and M. H. van Emden. 2001. <span>“Interval
Arithmetic: From Principles to Implementation.”</span> <em>Journal of
the ACM</em> 48: 1038–68.
</div>
<div id="ref-Hsiang1987" class="csl-entry">
Hsiang, Jieh, and Mandayam Srivas. 1987. <span>“Automatic Inductive
Theorem Proving Using Prolog.”</span> <em>Theoretical Computer
Science</em> 54 (1): 3–28.
</div>
<div id="ref-Kimmig2011" class="csl-entry">
Kimmig, Angelika, Bart Demoen, Luc De Raedt, Vítor Santos Costa, and
Ricardo Rocha. 2011. <span>“On the Implementation of the Probabilistic
Logic Programming Language ProbLog.”</span> <em>Theory and Practice of
Logic Programming</em> 11: 235–326.
</div>
<div id="ref-Kowalski1988" class="csl-entry">
Kowalski, Robert A. 1988. <span>“The Early Years of Logic
Programming.”</span> <em>Communications of the ACM</em> 31 (38).
</div>
<div id="ref-Lally2011" class="csl-entry">
Lally, Adam, and Paul Fodor. 2011. <span>“Natural Language Processing
with Prolog in the IBM Watson System.”</span>
</div>
<div id="ref-Newell1972" class="csl-entry">
Newell, Alan, and Herbert A. Simon. 1972. <em>Human Problem
Solving</em>. Englewood Cliffs, NJ: Prentice-Hall.
</div>
<div id="ref-R" class="csl-entry">
R Core Team. 2021. <em>R: A Language and Environment for Statistical
Computing</em>. Vienna, Austria: R Foundation for Statistical Computing.
<a href="https://www.R-project.org/">https://www.R-project.org/</a>.
</div>
<div id="ref-Sarkar2022" class="csl-entry">
Sarkar, Deepayan, and Kurt Hornik. 2022. <em>Enhancements to
<span>HTML</span> <span>D</span>ocumentation</em>. <a href="https://blog.r-project.org/2022/04/08/enhancements-to-html-documentation/index.html">https://blog.r-project.org/2022/04/08/enhancements-to-html-documentation/index.html</a>.
</div>
<div id="ref-Sato2001" class="csl-entry">
Sato, Taisuke, and Yoshitaka Kameya. 2013. <span>“Parameter Learning of
Logic Programs for Symbolic Statistical Modeling.”</span> <em>Journal of
AI Research</em> 15: 391–454.
</div>
<div id="ref-Shoham1994" class="csl-entry">
Shoham, Yoav. 1994. <em>Artificial Intelligence Techniques in
Prolog</em>. San Francisco: Morgan Kaufman.
</div>
<div id="ref-Triska2018" class="csl-entry">
Triska, Markus. 2018. <span>“Boolean Constraints in
<span>SWI-Prolog</span>: A Comprehensive System Description.”</span>
<em>Science of Computer Programming</em> 164: 98–115.
</div>
<div id="ref-Urbanek2021" class="csl-entry">
Urbanek, Simon. 2021. <em>Rserve: Binary r Server</em>. <a href="https://CRAN.R-project.org/package=Rserve">https://CRAN.R-project.org/package=Rserve</a>.
</div>
<div id="ref-Wickham2019" class="csl-entry">
Wickham, H. 2019. <em>Advanced <span>R</span></em>. Cambridge: Chapman
and Hall/CRC.
</div>
<div id="ref-Environ" class="csl-entry">
Wielemaker, Jan. 2012. <em>Demo Package with c Code, Fetching the
Program Environment</em>. <a href="https://www.swi-prolog.org/pack/list?p=environ">https://www.swi-prolog.org/pack/list?p=environ</a>.
</div>
<div id="ref-Wielemaker2021" class="csl-entry">
———. 2021a. <em>A c++ Interface to SWI-Prolog</em>. <a href="https://www.swi-prolog.org/pldoc/man?section=cpp-intro">https://www.swi-prolog.org/pldoc/man?section=cpp-intro</a>.
</div>
<div id="ref-Rserve" class="csl-entry">
———. 2021b. <em>Rserve Client for SWI-Prolog/SWISH</em>. <a href="https://github.com/JanWielemaker/rserve_client">https://github.com/JanWielemaker/rserve_client</a>.
</div>
<div id="ref-SWISH" class="csl-entry">
Wielemaker, Jan, Torbjörn Lager, and Fabrizio Riguzzi. 2015.
<span>“<span>SWISH:</span> SWI-Prolog for Sharing.”</span> <em>CoRR</em>
abs/1511.00915. <a href="https://arxiv.org/abs/1511.00915">https://arxiv.org/abs/1511.00915</a>.
</div>
<div id="ref-Wielemaker2012" class="csl-entry">
Wielemaker, Jan, Tom Schrijvers, Markus Triska, and Torbjörn Lager.
2012. <span>“SWI-Prolog.”</span> <em>Theory and Practice of Logic
Programming</em> 12 (1-2): 67–96. <a href="https://doi.org/10.1017/S1471068411000494">https://doi.org/10.1017/S1471068411000494</a>.
</div>
<div id="ref-Workman2021" class="csl-entry">
Workman, R. 2021. <em>clpBNR. Von CLP over Reals Using Interval
Arithmetic. Includes Rational, Integer and Boolean Domains as
Subsets</em>. <a href="https://github.com/ridgeworks/clpBNR">https://github.com/ridgeworks/clpBNR</a>.
</div>
<div id="ref-Xie2020" class="csl-entry">
Xie, Y., C. Dervieux, and E. Riederer. 2020. <em>R Markdown
Cookbook</em>. Cambridge: Chapman and Hall/CRC.
</div>
<div id="ref-Zinda2021" class="csl-entry">
Zinda, Eric. 2021. <em><span>MQI</span> – Python and Other Programming
Languge Integration for SWI Prolog</em>. <a href="https://www.swi-prolog.org/pldoc/man?section=mqi-overview">https://www.swi-prolog.org/pldoc/man?section=mqi-overview</a>.
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>

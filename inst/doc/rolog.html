<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Matthias Gondan (Department of Psychology, University of Innsbruck, Austria)" />

<meta name="date" content="2022-04-28" />

<title>rolog: Prolog queries from R</title>

<script src="data:application/javascript;base64,Ly8gUGFuZG9jIDIuOSBhZGRzIGF0dHJpYnV0ZXMgb24gYm90aCBoZWFkZXIgYW5kIGRpdi4gV2UgcmVtb3ZlIHRoZSBmb3JtZXIgKHRvCi8vIGJlIGNvbXBhdGlibGUgd2l0aCB0aGUgYmVoYXZpb3Igb2YgUGFuZG9jIDwgMi44KS4KZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uKGUpIHsKICB2YXIgaHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCJkaXYuc2VjdGlvbltjbGFzcyo9J2xldmVsJ10gPiA6Zmlyc3QtY2hpbGQiKTsKICB2YXIgaSwgaCwgYTsKICBmb3IgKGkgPSAwOyBpIDwgaHMubGVuZ3RoOyBpKyspIHsKICAgIGggPSBoc1tpXTsKICAgIGlmICghL15oWzEtNl0kL2kudGVzdChoLnRhZ05hbWUpKSBjb250aW51ZTsgIC8vIGl0IHNob3VsZCBiZSBhIGhlYWRlciBoMS1oNgogICAgYSA9IGguYXR0cmlidXRlczsKICAgIHdoaWxlIChhLmxlbmd0aCA+IDApIGgucmVtb3ZlQXR0cmlidXRlKGFbMF0ubmFtZSk7CiAgfQp9KTsK"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>



<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">
/* for pandoc --citeproc since 2.11 */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>

<link rel="stylesheet" href="data:text/css,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" type="text/css" />




</head>

<body>




<h1 class="title toc-ignore">rolog: Prolog queries from R</h1>
<h4 class="author">Matthias Gondan (Department of Psychology, University of Innsbruck, Austria)</h4>
<h4 class="date">2022-04-28</h4>



<p>Matthias Gondan<br />
Department of Psychology<br />
University of Innsbruck<br />
Innrain 9<br />
A-6020 Innsbruck<br />
<a href="mailto:Matthias.Gondan-Rochon@uibk.ac.at" class="email">Matthias.Gondan-Rochon@uibk.ac.at</a></p>
<div id="abstract" class="section level1">
<h1>Abstract</h1>
<p>Prolog is a classical logic programming language with many applications in expert systems, computer linguistics and traditional, that is, symbolic artificial intelligence. The main strength of Prolog is its concise representation of facts and rules for the representation of knowledge and grammar, as well as its very efficient built-in search engine for closed world domains. R is a statistical programming language for data analysis and statistical modeling which is widely used in academia and industry. Besides the core library, a lot of packages have been developed for all kinds of statistical problems, including new-style artificial intelligence tools such as neural networks for machine learning and deep learning. Whereas Prolog is weak in statistical computation, but strong in symbolic manipulation, the converse may be said for the R language. SWI-Prolog is a widely used Prolog system that offers a wide range of extensions for real world applications, and there already exist two so-called Prolog packs to invoke R (rserve-client, Real) from SWI-Prolog. However, given the large user community of R, there may also be a need for a connection in the reverse direction that allows invoking Prolog queries in R computations. The R package rolog embeds the SWI-Prolog system, thus enabling deterministic and non-deterministic queries to the Prolog interpreter. Usage of the rolog library is illustrated by a few examples.</p>
<div id="keywords" class="section level2">
<h2>Keywords</h2>
<p>Statistics; Logic Programming; Artificial Intelligence</p>
</div>
</div>
<div id="rolog-prolog-queries-from-r" class="section level1">
<h1>1. rolog: Prolog queries from R</h1>
<p>The R <span class="citation">(R Core Team 2021)</span> programming language and environment is a widely used open source software for statistical data analysis. The basic R is a functional language with lots of support for storage and manipulation of different data types, and a strong emphasis on operations involving vectors and arrays. Moreover, a huge number of R packages (e.g., CRAN, <a href="https://cran.r-project.org/" class="uri">https://cran.r-project.org/</a>) have been contributed that cover problems from diverse areas such as bioinformatics, machine learning, specialized statistical methods, web programming and connections to other programming languages. An interface to Prolog is lacking so far.</p>
<p>The logic programming language Prolog was invented in the 1970ies by Colmerauer <span class="citation">(Colmerauer and Roussel 1996)</span>, mostly for the purpose of natural language processing. Since then, logic programming has become an important driving force in research on artificial intelligence, natural language processing, program analysis, knowledge representation and theorem proving <span class="citation">(Shoham 1994; Lally and Fodor 2011; Carro 2004; Hsiang and Srivas 1987)</span>. SWI-Prolog <span class="citation">(Jan Wielemaker et al. 2012)</span> is an open-source implementation of Prolog that mainly targets developers of applications, with many users in academia, research and industry. SWI-Prolog includes a large number of libraries for “the real world”, for example, a web server, encryption, interfaces to C/C++ and other programming languages, as well as a development environment and debugger. In addition, pluggable extensions (so-called packs) are available for specific tasks to enhance its capabilities.</p>
<p>Unlike R, Prolog is a declarative programming language consisting of facts and rules that define relations, for example, in a problem space. Prolog’s major strength is its built-in query-driven search engine that efficiently deals with complex structured data, with the data not necessarily being numerical. In fact, Prolog only provides a basic collection of arithmetic calculations via a purely functional interface <code>is/2</code>. More complex calculations such as matrix algebra, statistical models or machine learning need help from other systems, for example, from R.</p>
<p>Angelopoulos et al. <span class="citation">(Angelopoulos et al. 2013)</span> summarize work at the intersection of symbolic knowledge representation and statistical interence, especially in the area of model fits <span class="citation">(EM algoritms, MCMC, Sato and Kameya 2013; Angelopoulos and Cussens 2008)</span> and stochastic logic programs <span class="citation">(Cussens 2000; ProbLog 2011)</span>. One of the major strengths of logic programming is handling constraints; and a number of systems for constraint satisfaction tools have been developed (constraint logic programming on booleans, finite domains, reals, and intervals) for that purpose <span class="citation">(e.g., Frühwirth 1998; Triska 2018)</span>. Some constraint handlers exist in R (see the CRAN task view for optimization problems), but more of them would be available via a bridge between R and Prolog.</p>
<p>Earlier approaches to connect Prolog and R have been published as SWI-Prolog packs <span class="citation">(real, Rserve_client, Angelopoulos et al. 2013; Jan Wielemaker 2021)</span> and as a YAP module <span class="citation">(YapR, Azevedo 2011)</span>. Whereas real establishes a direct link to an embedded instance of R, Rserve_client communicates with a local or remote R service <span class="citation">(Urbanek 2021)</span>. The former approach emphasises speed, the latter might be preferred from a security perspective, especially in systems such as SWISH <span class="citation">(Jan Wielemaker, Lager, and Riguzzi 2015)</span> that accept only a set of sandboxed commands for Prolog, but do not impose restrictions on R. A common feature of the two packages is that they provide an interface for R calls from Prolog, but not the other way round, that is, querying Prolog from R is not possible so far.</p>
<p>rolog is an attempt to fill this gap, and to offer the possibilty to raise Prolog queries in R scripts, for example, to perform efficient symbolic computations, searches in complex graphs, parsing natural language and definite clause grammars. In addition, two Prolog predicates are provided that enable Prolog to ring back to the R system for bidirectional communication. Similar to rreal, tight communication between the two systems is established by linking to a shared library that embeds the current version of SWI-Prolog. The exchange of data is facilitated by the C++ interfaces of the two languages <span class="citation">(Eddelbuettel and Balamuta 2018; J. Wielemaker 2021)</span>. A less tight connection might be established using the recently developed machine query interface <span class="citation">(Zinda 2021)</span> that allows socket-based communication between foreign languages and SWI-Prolog (and, in fact, the MQI documentation includes an example in which R is called).</p>
<p>A bidirectional bridge between R and Prolog might overcome the limitations of both languages, thereby combining the extensive numerical and statistical power of the R system with Prolog’s skills in the representation of knowledge and reasoning. In addition to the useful little tools shown in the examples below, rolog can therefore contribute to progress at the intersection of traditional artificial intelligence and contemporary statistical programming.</p>
<p>The next section presents the interface of rolog in detail. Section 3 presents possible extensions of the package at both ends, in R and Prolog. Section 4 is a list of illustrative examples that offer useful extensions to the R system. Conclusions and further perspectives are summarized in Section 5.</p>
</div>
<div id="basic-syntax" class="section level1">
<h1>2. Basic syntax</h1>
<p>rolog has a rather minimalistic syntax, providing only some basic ingredients to establish communication with an embedded SWI-Prolog. The ways to extend the interface are described in Section 3.</p>
<p>After installation (in R, with <code>install.packages(&quot;rolog&quot;)</code>), the package is loaded in the standard way using R’s <code>library</code>-command.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(rolog)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Welcome to SWI-Prolog (threaded, 64 bits, version 8.5.10-44-gdffbdb752-DIRTY)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; SWI-Prolog comes with ABSOLUTELY NO WARRANTY. This is free software.</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Please run ?- license. for legal details.</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; For online help and background, visit https://www.swi-prolog.org</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; For built-in help, use ?- help(Topic). or ?- apropos(Word).</span></span></code></pre></div>
<p>We can see SWI-Prolog’s typical welcome message.</p>
<div id="r-interface" class="section level2">
<h2>R interface</h2>
<p>Most of the work can done using the three R functions <code>query</code>, <code>submit</code>, and <code>clear</code>. The functions <code>consult</code>, <code>once</code>, and <code>findall</code> are provided for convenience.</p>
<p><em>consult</em>. In most applications, a number of Prolog facts and rules will be loaded into the system. To facilitate this recurrent task, the prolog directive <code>consult/1</code> has been mirrored into R, <code>consult(filename)</code>, with <em>filename</em> given as a string (or a list of strings if multiple files are to be consulted). Note that the full filename should be given, including the extension (e.g., “.pl”). The function returns <code>TRUE</code> on success; in case of problems, it returns <code>FALSE</code> and an error message is shown.</p>
<p><em>query</em>. The function <code>query(call, options)</code> is used to create a Prolog query (without invoking it yet). The first argument <em>call</em> is a regular R call that is created using R’s function <code>call(name, ...)</code>. This call represents the Prolog predicate which will be queried in the later course. The creation of such predicates and Prolog terms is described below and can become quite contrived (see the examples in Section 4). The second argument, <em>options</em>, may be used for ad hoc modifications of the translation between R and Prolog, see the section below. The function returns <code>TRUE</code> on success. Note that the function does not check if the corresponding Prolog predicate exists (but see <code>submit()</code> below).</p>
<p>Only a single query can be opened at a given time. If a new query is created while another query is still open, a warning is shown and the other query is closed.</p>
<p><em>submit</em>. Once a query has been created, it can be submitted using <code>submit()</code>. If the query fails, the return value is <code>FALSE</code>. If the query succeeds, a list of constraints is returned, with bindings for the variables that satisfy the query. Repeated calls to submit are possible, returning the different solutions of a query (until it eventually fails). Programmatically distinguishing between the different types of return values for success and failure (list vs. <code>FALSE</code>) is facilitated by the R function <code>isFALSE(x)</code>.</p>
<p><em>clear</em>. Closes the query. The name of the function is chosen to avoid name clashes with R’s own built-in function close. The function returns an invisible <code>TRUE</code>, even if there is no open query.</p>
<p>The following short R program illustrates a query to Prolog’s <code>member/2</code> using Rolog’s syntax rules.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># member(1, [1, 2.0, a, &quot;b&quot;, X])</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="fu">query</span>(<span class="fu">call</span>(<span class="st">&quot;member&quot;</span>, 1L, <span class="fu">list</span>(1L, <span class="fl">2.0</span>, <span class="fu">quote</span>(a), <span class="st">&quot;b&quot;</span>, <span class="fu">expression</span>(X), <span class="cn">TRUE</span>)))</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; attr(,&quot;query&quot;)</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] &quot;member(1, [1, 2.0, a, b, X, true])&quot;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co"># returns an empty list, stating that member(1, [1 | _]) is satisfied</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="fu">submit</span>()</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; list()</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co"># returns a list, stating that the query is also satisfied if X = 1</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="fu">submit</span>()</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; $X</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 1</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="co"># close the query</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="fu">clear</span>()</span></code></pre></div>
<dl>
<dt>Listing 1.</dt>
<dd>A query to Prolog’s <code>member/2</code> predicate.
</dd>
</dl>
<p><em>once</em> and <em>findall</em>. The function <code>once(call, options)</code> is a convenience function that acts as a shortcut for <code>query(call, options)</code>, <code>submit()</code>, and <code>clear()</code>. Similarly, <code>findall(call, options)</code> abbreviates the commands <code>query(call, options)</code>, repetition of <code>submit()</code> until failure, and <code>clear()</code>, returning a list collecting the the return value of the individual calls to submit.</p>
</div>
<div id="creating-prolog-terms-in-r" class="section level2">
<h2>Creating Prolog terms in R</h2>
<p>Table 1 summarizes the rules for the translation from R to Prolog. Most rules work in both directions, but a few exceptions exist. For example, there is an empty atom in Prolog, but no empty symbol in R, so the empty atom is translated to a character string in R.</p>
<dl>
<dt>Table 1</dt>
<dd>Creating Prolog terms from R
</dd>
</dl>
<table>
<thead>
<tr class="header">
<th align="left">R</th>
<th align="left">Prolog</th>
<th align="left">Note/Alternatives</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>expression(X)</code></td>
<td align="left">Variable X</td>
<td align="left">not necessarily uppercase</td>
</tr>
<tr class="even">
<td align="left"><code>as.symbol(abc)</code></td>
<td align="left">Atom abc</td>
<td align="left"><code>as.name</code>, <code>quote</code></td>
</tr>
<tr class="odd">
<td align="left"><code>TRUE</code>, <code>FALSE</code>, <code>NULL</code></td>
<td align="left">Atoms true, false, null</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><code>&quot;abc&quot;</code></td>
<td align="left">String &quot;abc&quot;</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"><code>3L</code></td>
<td align="left">Integer 3</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><code>3</code></td>
<td align="left">Float 3.0</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"><code>call(&quot;term&quot;, 1L, 2L)</code></td>
<td align="left">term(1, 2)</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><code>list(1L, 2L, 3L)</code></td>
<td align="left">List [1, 2, 3]</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"><code>list(a=1, b=2, c=3)</code></td>
<td align="left">List [a-1, b-2, c-3]</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><code>c(1, 2, 3)</code></td>
<td align="left">#(1.0, 2.0, 3.0)</td>
<td align="left">vectors of length &gt; 1</td>
</tr>
<tr class="odd">
<td align="left"><code>c(1L, 2L, 3L)</code> or <code>1:3</code></td>
<td align="left">&#39;%&#39;(1, 2, 3)</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><code>c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</code></td>
<td align="left">$$(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"><code>c(TRUE, FALSE, NA)</code></td>
<td align="left">!(true, false, na)</td>
<td align="left"></td>
</tr>
</tbody>
</table>
<p>Moreover, R is mostly vectorized, lacking support for scalar entities, that is, scalar entities are treated as vectors of length 1. Conversely, Prolog does not natively support vectors or matrices. The problem is solved in the following way:</p>
<ul>
<li>R vectors of length 0 are translated to Prolog’s empty list.</li>
<li>R vectors of length 1 are translated to Prolog scalars.</li>
<li>R vectors of length <em>N</em> &gt; 1 are translated to Prolog terms <code>#/N</code>, <code>%/N</code>, <code>$$/N</code>, and <code>!/N</code> for floating points, integers, strings and logicals, respectively.</li>
</ul>
<p>In the reverse direction, Prolog terms like <code>#/N</code> are translated back to R vectors of length <em>N</em>, including terms <code>#/0</code> and <code>#/1</code> that map to R vectors of length 0 and 1, respectively. To summarize, the rules for translation are not fully symmetrical. A quick check for symmetry of the representation is obtained by a query to <code>r_eval/2</code> (see also below, subsection Prolog interface):</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">once</span>(<span class="fu">call</span>(<span class="st">&quot;r_eval&quot;</span>, <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="cn">NA</span>, <span class="cn">NaN</span>, <span class="cn">Inf</span>), <span class="fu">expression</span>(X)))</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; $X</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1]   1   2  NA NaN Inf</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; attr(,&quot;query&quot;)</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] &quot;r_eval(#(1.0, 2.0, na, 1.5NaN, 1.0Inf), X)&quot;</span></span></code></pre></div>
</div>
<div id="package-options" class="section level2">
<h2>Package options</h2>
<p>A few package-specific options have been defined to allow some finetuning of the rules for translation between R and Prolog.</p>
<ul>
<li>realvec (string): Name of the prolog term for vectors of floats (default is #)</li>
<li>intvec (string): same for vectors of integers (default is %)</li>
<li>boolvec (string): same for vectors of logicals (default is !)</li>
<li>charvec (string): same for vectors of character strings (default is $$). The single dollar cannot be used because it is the list operator in R.</li>
<li>scalar (logical): if <code>TRUE</code> (default), R vectors of length 1 are translated to scalars in Prolog. If <code>FALSE</code>, R vectors are always translated to <code>#/N</code> etc., depending on the type.</li>
<li>portray (logical): if <code>TRUE (default)</code>, the result of <code>query</code>, <code>once</code> and <code>findall</code> includes an attribute with a representation of the query in Prolog.</li>
</ul>
<p>The command <code>rolog_options()</code> returns a list with all the options. The options can be globally modified like e.g. this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">options</span>(<span class="at">rolog.intvec=</span><span class="st">&quot;%%&quot;</span>)</span></code></pre></div>
<p>In a given query, the options can be set in the optional argument, e.g.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">query</span>(<span class="fu">call</span>(<span class="st">&quot;member&quot;</span>, <span class="fu">expression</span>(X), <span class="fu">list</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>, <span class="dv">4</span><span class="sc">:</span><span class="dv">6</span>)), <span class="at">options=</span><span class="fu">list</span>(<span class="at">intvec=</span><span class="st">&quot;%%&quot;</span>))</span></code></pre></div>
</div>
<div id="prolog-interface" class="section level2">
<h2>Prolog interface</h2>
<p>rolog offers some basic support to call R from Prolog, that is, connecting the two systems in the reverse direction. Two predicates can be used for this purpose, <code>r_eval(Call)</code> and <code>r_eval(Function, Result)</code>. The former just invokes R with the command <em>Call</em> (ignoring the result); the latter evaluates <em>Function</em> and unifies the result with <em>Result</em>. Note that proper quoting of R functions is needed at the Prolog end, especially with R functions that start with uppercase letters or contain a dot in their name.</p>
<p>Two use cases for <code>r_eval/2</code> are shown in Section 4 below.</p>
</div>
</div>
<div id="extending-the-package" class="section level1">
<h1>3. Extending the package</h1>
<p>The package is intentionally kept minimalistic, but can easily be extended by convenience functions on both ends, Prolog and R, to facilitate recurrent tasks and/or avoid cumbersome syntax. R is a functional language, whereas Prolog is declarative. Obviously, there cannot be a perfect one-to-one correspondence between the syntactic components of two programming languages that follow completely different paradigms. Whereas symbols, functions, numbers and character strings are easily mapped between R and Prolog, there are loose ends at both sides. In particular, Prolog variables are translated from and to R <em>expressions</em> (not to be confused with R symbols), and R vectors of length <em>N</em> &gt; 1 are translated to the Prolog terms <code>#/N</code>, <code>%/N</code>, <code>!/N</code>, and <code>$$/N</code>, as mentioned above.</p>
<p>These rules are, in principle, arbitrary and can be intercepted at several stages of the process:</p>
<ul>
<li>R functions that may be used to preprocess specific R elements before translation into Prolog (see, e.g., the R function <code>as.rolog()</code>)</li>
<li>Prolog wrappers that manipulate the term before it is called and afterwards (see the dicts below)</li>
<li>R functions that postprocess the result of a query</li>
</ul>
<p>The process is illustrated in Figure 1.</p>
<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.40.1 (20161225.0304)
 -->
<!-- Title: G Pages: 1 -->
<svg width="543pt" height="140pt" viewBox="0.00 0.00 543.44 140.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 136)">
<title>G</title>
<polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-136 539.4426,-136 539.4426,4 -4,4"></polygon>
<g id="clust1" class="cluster">
<title>cluster_0</title>
<polygon fill="#d3d3d3" stroke="#d3d3d3" points="113.7627,-72 113.7627,-124 431.1352,-124 431.1352,-72 113.7627,-72"></polygon>
</g>
<g id="clust2" class="cluster">
<title>cluster_1</title>
<polygon fill="#d3d3d3" stroke="#d3d3d3" points="111.0327,-8 111.0327,-60 433.8652,-60 433.8652,-8 111.0327,-8"></polygon>
</g>
<!-- Query -->
<g id="node1" class="node">
<title>Query</title>
<polygon fill="none" stroke="#000000" points="41.5163,-125 -.0164,-100 41.5163,-75 83.049,-100 41.5163,-125"></polygon>
<polyline fill="none" stroke="#000000" points="10.2648,-106.1886 10.2648,-93.8114 "></polyline>
<polyline fill="none" stroke="#000000" points="31.2352,-81.1886 51.7975,-81.1886 "></polyline>
<polyline fill="none" stroke="#000000" points="72.7679,-93.8114 72.7679,-106.1886 "></polyline>
<polyline fill="none" stroke="#000000" points="51.7975,-118.8114 31.2352,-118.8114 "></polyline>
<text text-anchor="middle" x="41.5163" y="-95.8" font-family="Times,serif" font-size="14.00" fill="#000000">Query</text>
</g>
<!-- r2rolog -->
<g id="node3" class="node">
<title>r2rolog</title>
<polygon fill="#ffffff" stroke="#ffffff" points="200.1212,-116 121.9757,-116 121.9757,-80 200.1212,-80 200.1212,-116"></polygon>
<text text-anchor="middle" x="161.0485" y="-93.8" font-family="Times,serif" font-size="14.00" fill="#000000">preproc(...)</text>
</g>
<!-- Query&#45;&gt;r2rolog -->
<g id="edge5" class="edge">
<title>Query-&gt;r2rolog</title>
<path fill="none" stroke="#000000" d="M81.9845,-99.3229C91.5353,-99.1631 101.8227,-98.991 111.7164,-98.8254"></path>
<polygon fill="#000000" stroke="#000000" points="111.8968,-102.323 121.8368,-98.6561 111.7796,-95.324 111.8968,-102.323"></polygon>
</g>
<!-- Result -->
<g id="node2" class="node">
<title>Result</title>
<polygon fill="none" stroke="#000000" points="67.2938,-56.7775 15.7389,-56.7775 15.7389,-5.2225 67.2938,-5.2225 67.2938,-56.7775"></polygon>
<polyline fill="none" stroke="#000000" points="27.7389,-56.7775 15.7389,-44.7775 "></polyline>
<polyline fill="none" stroke="#000000" points="15.7389,-17.2225 27.7389,-5.2225 "></polyline>
<polyline fill="none" stroke="#000000" points="55.2938,-5.2225 67.2938,-17.2225 "></polyline>
<polyline fill="none" stroke="#000000" points="67.2938,-44.7775 55.2938,-56.7775 "></polyline>
<text text-anchor="middle" x="41.5163" y="-26.8" font-family="Times,serif" font-size="14.00" fill="#000000">Result</text>
</g>
<!-- rolog2r -->
<g id="node6" class="node">
<title>rolog2r</title>
<polygon fill="#ffffff" stroke="#ffffff" points="203.0801,-52 119.0169,-52 119.0169,-16 203.0801,-16 203.0801,-52"></polygon>
<text text-anchor="middle" x="161.0485" y="-29.8" font-family="Times,serif" font-size="14.00" fill="#000000">postproc(...)</text>
</g>
<!-- Result&#45;&gt;rolog2r -->
<g id="edge8" class="edge">
<title>Result-&gt;rolog2r</title>
<path fill="none" stroke="#000000" d="M77.8161,-31.911C90.7172,-32.2348 105.3525,-32.6022 118.714,-32.9375"></path>
<polygon fill="#000000" stroke="#000000" points="77.5377,-28.4031 67.453,-31.651 77.362,-35.4008 77.5377,-28.4031"></polygon>
</g>
<!-- forth -->
<g id="node4" class="node">
<title>forth</title>
<ellipse fill="#ffffff" stroke="#ffffff" cx="276.9143" cy="-98" rx="37.7006" ry="18"></ellipse>
<text text-anchor="middle" x="276.9143" y="-93.8" font-family="Times,serif" font-size="14.00" fill="#000000">(rolog)</text>
</g>
<!-- r2rolog&#45;&gt;forth -->
<g id="edge1" class="edge">
<title>r2rolog-&gt;forth</title>
<path fill="none" stroke="#000000" d="M200.2754,-98C209.4358,-98 219.2952,-98 228.7923,-98"></path>
<polygon fill="#000000" stroke="#000000" points="228.9053,-101.5001 238.9053,-98 228.9053,-94.5001 228.9053,-101.5001"></polygon>
</g>
<!-- rolog_pl -->
<g id="node5" class="node">
<title>rolog_pl</title>
<polygon fill="#ffffff" stroke="#ffffff" points="422.9567,-116 353.6728,-116 353.6728,-80 422.9567,-80 422.9567,-116"></polygon>
<text text-anchor="middle" x="388.3147" y="-93.8" font-family="Times,serif" font-size="14.00" fill="#000000">preproc/2</text>
</g>
<!-- forth&#45;&gt;rolog_pl -->
<g id="edge2" class="edge">
<title>forth-&gt;rolog_pl</title>
<path fill="none" stroke="#000000" d="M314.9404,-98C324.1055,-98 333.9828,-98 343.4286,-98"></path>
<polygon fill="#000000" stroke="#000000" points="343.4549,-101.5001 353.4549,-98 343.4548,-94.5001 343.4549,-101.5001"></polygon>
</g>
<!-- Prolog -->
<g id="node9" class="node">
<title>Prolog</title>
<ellipse fill="none" stroke="#000000" cx="498.6539" cy="-66" rx="36.5786" ry="36.5786"></ellipse>
<polyline fill="none" stroke="#000000" points="522.986,-93.5915 474.3219,-93.5915 "></polyline>
<polyline fill="none" stroke="#000000" points="522.986,-38.4085 474.3219,-38.4085 "></polyline>
<text text-anchor="middle" x="498.6539" y="-61.8" font-family="Times,serif" font-size="14.00" fill="#000000">Prolog</text>
</g>
<!-- rolog_pl&#45;&gt;Prolog -->
<g id="edge6" class="edge">
<title>rolog_pl:e-&gt;Prolog</title>
<path fill="none" stroke="#000000" d="M423.3147,-98C435.0752,-98 447.1053,-94.6558 458.0017,-90.1297"></path>
<polygon fill="#000000" stroke="#000000" points="459.6104,-93.2427 467.2502,-85.9022 456.7003,-86.8763 459.6104,-93.2427"></polygon>
</g>
<!-- back -->
<g id="node7" class="node">
<title>back</title>
<ellipse fill="#ffffff" stroke="#ffffff" cx="276.9143" cy="-34" rx="37.7006" ry="18"></ellipse>
<text text-anchor="middle" x="276.9143" y="-29.8" font-family="Times,serif" font-size="14.00" fill="#000000">(rolog)</text>
</g>
<!-- rolog2r&#45;&gt;back -->
<g id="edge3" class="edge">
<title>rolog2r-&gt;back</title>
<path fill="none" stroke="#000000" d="M213.4869,-34C222.0216,-34 230.7168,-34 238.8225,-34"></path>
<polygon fill="#000000" stroke="#000000" points="213.2065,-30.5001 203.2065,-34 213.2064,-37.5001 213.2065,-30.5001"></polygon>
</g>
<!-- pl_rolog -->
<g id="node8" class="node">
<title>pl_rolog</title>
<polygon fill="#ffffff" stroke="#ffffff" points="425.9158,-52 350.7137,-52 350.7137,-16 425.9158,-16 425.9158,-52"></polygon>
<text text-anchor="middle" x="388.3147" y="-29.8" font-family="Times,serif" font-size="14.00" fill="#000000">postproc/2</text>
</g>
<!-- back&#45;&gt;pl_rolog -->
<g id="edge4" class="edge">
<title>back-&gt;pl_rolog</title>
<path fill="none" stroke="#000000" d="M325.114,-34C333.595,-34 342.3123,-34 350.46,-34"></path>
<polygon fill="#000000" stroke="#000000" points="324.9405,-30.5001 314.9404,-34 324.9404,-37.5001 324.9405,-30.5001"></polygon>
</g>
<!-- pl_rolog&#45;&gt;Prolog -->
<g id="edge7" class="edge">
<title>pl_rolog:e-&gt;Prolog</title>
<path fill="none" stroke="#000000" d="M436.4748,-34.8303C447.5233,-36.5766 458.4,-40.8717 467.8907,-45.7339"></path>
<polygon fill="#000000" stroke="#000000" points="436.5666,-31.3262 426.3147,-34 435.9964,-38.303 436.5666,-31.3262"></polygon>
</g>
</g>
</svg>

<dl>
<dt>Figure 1</dt>
<dd>Workflow in rolog
</dd>
</dl>
<div id="preprocessing-in-r" class="section level2">
<h2>Preprocessing in R</h2>
<p>We have seen above that raising even simple everyday Prolog queries such as <code>member(X, [1, 2, 3, a, b])</code> require complicated R expressions such as</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">query</span>(<span class="fu">call</span>(<span class="st">&quot;member&quot;</span>, <span class="fu">expression</span>(X), <span class="fu">list</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="fu">as.symbol</span>(<span class="st">&quot;a&quot;</span>), <span class="fu">quote</span>(b)))</span></code></pre></div>
<p>The R function <code>as.rolog(call)</code> is meant to simplify this a bit by translating symbols starting with a dot to Prolog variables, and calls like <code>&quot;&quot;[1, 2, 3, a, b]</code> to lists. The argument <em>call</em> is typically a quoted R call or symbol:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>q <span class="ot">&lt;-</span> <span class="fu">quote</span>(<span class="fu">member</span>(.X, <span class="st">&quot;&quot;</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, a, b]))</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="fu">query</span>(<span class="fu">as.rolog</span>(q))</span></code></pre></div>
<p>Note that the name of the variable will still be <em>X</em> in the later course, not “dot-X”. A bit flexibility is lost because <code>quote()</code> treats the arguments <em>a</em>, <em>b</em> as symbols; to evaluate them (i.e., “unquote”), they can be put in parentheses:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">&lt;-</span> <span class="dv">4</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>b <span class="ot">&lt;-</span> <span class="dv">5</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>q <span class="ot">&lt;-</span> <span class="fu">quote</span>(<span class="fu">member</span>(.X, <span class="st">&quot;&quot;</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, a, (b)]))</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="fu">query</span>(<span class="fu">as.rolog</span>(q))</span></code></pre></div>
<p>resulting in the query <code>member(X, [1, 2, 3, a, 5])</code>. More sophisticated work with quasi-quotations (i.e., “unquoting” expressions) is described in the “Advanced R” book <span class="citation">(Wickham 2019)</span>.</p>
<p>Section 4 includes an example for mathematical rendering of R expressions. In that example, a preprocessing function is used to bring function calls with named arguments to a canonical form which is then handled in Prolog.</p>
</div>
<div id="postprocessing-in-r" class="section level2">
<h2>Postprocessing in R</h2>
<p>This may again be a function that reverts some of the manipulations during preprocessing. For <code>once()</code> and <code>submit()</code>, such a function would operate on the bindings. For example, many Prolog programmers are used to operate with atoms instead of character strings, the latter being the preferred representation of symbolic information in R. The following simple example illustrates conversion of the results for a query like <code>member(X, [a, b, c])</code> to strings.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>stringify <span class="ot">&lt;-</span> <span class="cf">function</span>(x)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># replace Prolog variable by the value of an R variable with the same name</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(<span class="fu">is.name</span>(x))</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>      <span class="fu">return</span>(<span class="fu">as.character</span>(x))</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Recurse into lists and calls</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(<span class="fu">is.call</span>(x))</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>      x[<span class="sc">-</span><span class="dv">1</span>] <span class="ot">&lt;-</span> <span class="fu">lapply</span>(x[<span class="sc">-</span><span class="dv">1</span>], <span class="at">FUN=</span>stringify)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(<span class="fu">is.list</span>(x))</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>      x <span class="ot">&lt;-</span> <span class="fu">lapply</span>(x, <span class="at">FUN=</span>stringify)</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Leave the rest unchanged</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span>(x)</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Example illustration</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>q <span class="ot">&lt;-</span> <span class="fu">quote</span>(<span class="fu">member</span>(.X, <span class="st">&quot;&quot;</span>[a, b, c]))</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>r <span class="ot">&lt;-</span> <span class="fu">findall</span>(<span class="fu">as.rolog</span>(q))</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a><span class="fu">stringify</span>(r)</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [[1]]</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [[1]]$X</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] &quot;a&quot;</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [[2]]</span></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [[2]]$X</span></span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] &quot;b&quot;</span></span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [[3]]</span></span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [[3]]$X</span></span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] &quot;c&quot;</span></span></code></pre></div>
</div>
<div id="pre--and-postprocessing-in-prolog" class="section level2">
<h2>Pre- and postprocessing in Prolog</h2>
<p>Recent versions of SWI-Prolog support so-called dictionaries of the form <code>Tag{Key1:Value1, Key2:Value2, ...}</code>. The tag is typically an atom (but can be a variable, as well), the keys are unique atom or integers; the values can be anything. Suppose we have a Prolog predicate that does something with dicts, and we would like to query it from R. The simplest solution is a wrapper in Prolog that translates key-value pairs <code>[Key1-Value1, Key2-Value2, ...]</code> back and forth to dicts:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>do_something_with_pairs(<span class="dt">Pairs0</span><span class="kw">,</span> <span class="dt">Pairs1</span>) <span class="kw">:-</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    dict_pairs(<span class="dt">Dict0</span><span class="kw">,</span> my_dict<span class="kw">,</span> <span class="dt">Pairs0</span>)<span class="kw">,</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    do_something_with_dicts(<span class="dt">Dict0</span><span class="kw">,</span> <span class="dt">Dict1</span>)<span class="kw">,</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    dict_pairs(<span class="dt">Dict1</span><span class="kw">,</span> my_dict<span class="kw">,</span> <span class="dt">Pairs1</span>)<span class="kw">.</span></span></code></pre></div>
<p><code>do_something_with_pairs/2</code> can then be queried from R using, e.g., lists with named elements.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">once</span>(<span class="fu">call</span>(<span class="st">&quot;do_something_with_pairs&quot;</span>, <span class="fu">list</span>(<span class="at">a=</span><span class="dv">1</span>, <span class="at">b=</span><span class="dv">2</span>), <span class="fu">expression</span>(X)))</span></code></pre></div>
<p>In the code above, <code>dict_pairs/2</code> takes the role of both <code>preproc/2</code> and <code>postproc/2</code> in Figure 1. It illustrates that complicated syntax on the R side when can be much simpler to do the conversion at the Prolog end.</p>
<p>A way to extend Prolog by add-ons (“packs”) are shown in the next section.</p>
</div>
</div>
<div id="examples" class="section level1">
<h1>4. Examples</h1>
<p>In this section I present a few usage examples for the rolog package in increasing complexity. Although the code snippets are mostly self-explanatory, some familiarity with the Prolog language is helpful.</p>
<div id="hello-world" class="section level2">
<h2>Hello, world</h2>
<p>Prolog’s typical <em>hello world</em> example is a search through a directed acyclic graph (DAG), for example, a family tree like the one given in Listing 1.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>parent(pam<span class="kw">,</span> bob)<span class="kw">.</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>parent(tom<span class="kw">,</span> bob)<span class="kw">.</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>parent(bob<span class="kw">,</span> ann)<span class="kw">.</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>parent(bob<span class="kw">,</span> pat)<span class="kw">.</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>parent(pat<span class="kw">,</span> jim)<span class="kw">.</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>ancestor(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Z</span>) <span class="kw">:-</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    parent(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Z</span>)<span class="kw">.</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>ancestor(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Z</span>) <span class="kw">:-</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    parent(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>)<span class="kw">,</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    ancestor(<span class="dt">Y</span><span class="kw">,</span> <span class="dt">Z</span>)<span class="kw">.</span></span></code></pre></div>
<dl>
<dt>Listing 1</dt>
<dd>A family tree in Prolog (see also family.pl)
</dd>
</dl>
<p>Listing 1 is included in the package and can be accessed from R using the function <code>system.file(...)</code>. Within Prolog, the normal workflow is to consult the code with <code>[family]</code> and then to raise queries such as <code>ancestor(X, jim)</code>, which returns, one by one, four solutions for the variable <em>X</em>. In R, we obtain the following results:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(rolog)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="co"># [family].</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="fu">consult</span>(<span class="fu">system.file</span>(<span class="fu">file.path</span>(<span class="st">&quot;pl&quot;</span>, <span class="st">&quot;family.pl&quot;</span>), <span class="at">package=</span><span class="st">&quot;rolog&quot;</span>))</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="co"># ancestor(X, jim).</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="fu">query</span>(<span class="fu">call</span>(<span class="st">&quot;ancestor&quot;</span>, <span class="fu">expression</span>(X), <span class="fu">quote</span>(jim)))</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; attr(,&quot;query&quot;)</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] &quot;ancestor(X, jim)&quot;</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span class="co"># solutions for X, one by one</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a><span class="fu">submit</span>()</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; $X</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; pat</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a><span class="fu">submit</span>()</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; $X</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; pam</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a><span class="fu">submit</span>()</span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; $X</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; tom</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a><span class="fu">submit</span>()</span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; $X</span></span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; bob</span></span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a><span class="fu">submit</span>() <span class="co"># no more results (closing the query)</span></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] FALSE</span></span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a><span class="fu">submit</span>() <span class="co"># warning that no query is open</span></span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Warning in .submit(): submit: no open query.</span></span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] FALSE</span></span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a><span class="co"># clear() # normally used to close a query</span></span></code></pre></div>
<p>As stated above, <code>consult()</code> loads the facts and rules of Listing 1 into the database. <code>query(expr)</code> initializes the query <code>expr</code>, and the subsequent calls to <code>submit</code> return the conditions under which the query succeeds. In this example, the query succeeds if <em>X</em> is either <code>pat</code>, <code>pam</code>, <code>tom</code> or <code>bob</code>. A query is closed with <code>clear()</code>, or automatically if the query fails. Note that it is generally not possible to open two queries simultaneously, so opening a second query while another one is still open will raise a warning. If we are interested in just the first solution, we can use <code>once(expr)</code> as a shortcut to <code>query(expr)</code>-<code>submit()</code>-<code>clear()</code>. If we want to collect all solutions of a query with a finite set of solutions, we can use <code>findall(expr)</code>.</p>
<p>A rather cumbersome aspect of Rolog is the construction of Prolog terms and queries. <code>expression(X)</code> encapsulates the variable <code>X</code>, R symbols from <code>quote(jim)</code> or <code>as.symbol(&quot;jim&quot;)</code> are translated to Prolog atoms, and Prolog compounds such as <code>ancestor/2</code> are generated using <code>call(&quot;ancestor&quot;, ...)</code>. A simplified syntax is provided by <code>as.rolog(...)</code> that accepts quoted expressions with dots indicating Prolog variables:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>q <span class="ot">=</span> <span class="fu">quote</span>(<span class="fu">ancestor</span>(.X, jim))</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="fu">findall</span>(<span class="fu">as.rolog</span>(q))</span></code></pre></div>
<p>Note that <code>as.rolog(...)</code> removes the dot from the variable name (<code>.X</code> to <code>X</code>).</p>
</div>
<div id="backdoor-test" class="section level2">
<h2>Backdoor test</h2>
<p>A more useful application of DAGs is confounder adjustment in causal analysis <span class="citation">(Greenland, Pearl, and Robins 1999; Barrett 2021)</span>. The Prolog file <code>backdoor.pl</code> is an implementation of Greenland et al.’s criteria for the backdoor test for <em>d</em>-separation in DAGs, with a predicate <code>minimal/3</code> that searches for minimally sufficient sets of variables for confounder adjustment on the causal path between exposure and outcome.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># [backdoor].</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="fu">consult</span>(<span class="fu">system.file</span>(<span class="fu">file.path</span>(<span class="st">&quot;pl&quot;</span>, <span class="st">&quot;backdoor.pl&quot;</span>), <span class="at">package=</span><span class="st">&quot;rolog&quot;</span>))</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Figure 12 in Greenland et al.</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>add_node <span class="ot">=</span> <span class="cf">function</span>(N)</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">invisible</span>(<span class="fu">once</span>(<span class="fu">call</span>(<span class="st">&quot;assert&quot;</span>, <span class="fu">call</span>(<span class="st">&quot;node&quot;</span>, N))))</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>add_arrow <span class="ot">=</span> <span class="cf">function</span>(X, Y)</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    <span class="fu">invisible</span>(<span class="fu">once</span>(<span class="fu">call</span>(<span class="st">&quot;assert&quot;</span>, <span class="fu">call</span>(<span class="st">&quot;arrow&quot;</span>, X, Y))))</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a><span class="fu">add_node</span>(<span class="st">&quot;a&quot;</span>)</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a><span class="fu">add_node</span>(<span class="st">&quot;b&quot;</span>)</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a><span class="fu">add_node</span>(<span class="st">&quot;c&quot;</span>)</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a><span class="fu">add_node</span>(<span class="st">&quot;d&quot;</span>) <span class="co"># outcome</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a><span class="fu">add_node</span>(<span class="st">&quot;e&quot;</span>) <span class="co"># exposure</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a><span class="fu">add_node</span>(<span class="st">&quot;f&quot;</span>)</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a><span class="fu">add_node</span>(<span class="st">&quot;u&quot;</span>)</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a><span class="fu">add_arrow</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;d&quot;</span>)</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a><span class="fu">add_arrow</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;f&quot;</span>)</span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a><span class="fu">add_arrow</span>(<span class="st">&quot;b&quot;</span>, <span class="st">&quot;d&quot;</span>)</span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a><span class="fu">add_arrow</span>(<span class="st">&quot;b&quot;</span>, <span class="st">&quot;f&quot;</span>)</span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a><span class="fu">add_arrow</span>(<span class="st">&quot;c&quot;</span>, <span class="st">&quot;d&quot;</span>)</span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a><span class="fu">add_arrow</span>(<span class="st">&quot;c&quot;</span>, <span class="st">&quot;f&quot;</span>)</span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a><span class="fu">add_arrow</span>(<span class="st">&quot;e&quot;</span>, <span class="st">&quot;d&quot;</span>)</span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a><span class="fu">add_arrow</span>(<span class="st">&quot;f&quot;</span>, <span class="st">&quot;e&quot;</span>)</span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a><span class="fu">add_arrow</span>(<span class="st">&quot;u&quot;</span>, <span class="st">&quot;a&quot;</span>)</span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a><span class="fu">add_arrow</span>(<span class="st">&quot;u&quot;</span>, <span class="st">&quot;b&quot;</span>)</span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a><span class="fu">add_arrow</span>(<span class="st">&quot;u&quot;</span>, <span class="st">&quot;c&quot;</span>)</span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a><span class="fu">findall</span>(<span class="fu">call</span>(<span class="st">&quot;minimal&quot;</span>, <span class="st">&quot;e&quot;</span>, <span class="st">&quot;d&quot;</span>, <span class="fu">expression</span>(S)))</span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [[1]]</span></span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [[1]]$S</span></span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [[1]]$S[[1]]</span></span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] &quot;a&quot;</span></span>
<span id="cb15-37"><a href="#cb15-37" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb15-38"><a href="#cb15-38" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [[1]]$S[[2]]</span></span>
<span id="cb15-39"><a href="#cb15-39" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] &quot;b&quot;</span></span>
<span id="cb15-40"><a href="#cb15-40" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb15-41"><a href="#cb15-41" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [[1]]$S[[3]]</span></span>
<span id="cb15-42"><a href="#cb15-42" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] &quot;c&quot;</span></span>
<span id="cb15-43"><a href="#cb15-43" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb15-44"><a href="#cb15-44" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb15-45"><a href="#cb15-45" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb15-46"><a href="#cb15-46" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [[2]]</span></span>
<span id="cb15-47"><a href="#cb15-47" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [[2]]$S</span></span>
<span id="cb15-48"><a href="#cb15-48" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [[2]]$S[[1]]</span></span>
<span id="cb15-49"><a href="#cb15-49" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] &quot;f&quot;</span></span>
<span id="cb15-50"><a href="#cb15-50" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb15-51"><a href="#cb15-51" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb15-52"><a href="#cb15-52" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb15-53"><a href="#cb15-53" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; attr(,&quot;query&quot;)</span></span>
<span id="cb15-54"><a href="#cb15-54" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] &quot;minimal(e, d, S)&quot;</span></span></code></pre></div>
<p>The query to <code>minimal/3</code> returns two minimally sufficient sets of covariates for confounder adjustment (namely, {a, b, c} and {f}).</p>
</div>
<div id="definite-clause-grammars" class="section level2">
<h2>Definite clause grammars</h2>
<p>One of the main driving forces of Prolog development was natural language processing <span class="citation">(Dahl 1981)</span>. Therefore, the next example is an illustration of sentence parsing using so-called definite clause grammars. As Listing 3 shows, rolog can access modules from SWI’s standard library (e.g., “dcg/basics.pl”).</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">:-</span> use_module(library(dcg<span class="fu">/</span>basics))<span class="kw">.</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="co">% Translate R string to code points and invoke phrase/2</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>sentence(<span class="dt">Tree</span><span class="kw">,</span> <span class="dt">Sentence</span>) <span class="kw">:-</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    string_codes(<span class="dt">Sentence</span><span class="kw">,</span> <span class="dt">Codes</span>)<span class="kw">,</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">phrase</span>(s(<span class="dt">Tree</span>)<span class="kw">,</span> <span class="dt">Codes</span>)<span class="kw">.</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="co">% Simple grammar with sentences, noun, verb and participle phrases</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>s(s(<span class="dt">NP</span><span class="kw">,</span> <span class="dt">VP</span>)) <span class="kw">--&gt;</span> np(<span class="dt">NP</span><span class="kw">,</span> <span class="dt">C</span>)<span class="kw">,</span> blank<span class="kw">,</span> vp(<span class="dt">VP</span><span class="kw">,</span> <span class="dt">C</span>)<span class="kw">.</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>np(<span class="dt">NP</span><span class="kw">,</span> <span class="dt">C</span>) <span class="kw">--&gt;</span> pn(<span class="dt">NP</span><span class="kw">,</span> <span class="dt">C</span>)<span class="kw">.</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>np(np(<span class="dt">Det</span><span class="kw">,</span> <span class="dt">N</span>)<span class="kw">,</span> <span class="dt">C</span>) <span class="kw">--&gt;</span> det(<span class="dt">Det</span><span class="kw">,</span> <span class="dt">C</span>)<span class="kw">,</span> blank<span class="kw">,</span> n(<span class="dt">N</span><span class="kw">,</span> <span class="dt">C</span>)<span class="kw">.</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>np(np(<span class="dt">Det</span><span class="kw">,</span> <span class="dt">N</span><span class="kw">,</span> <span class="dt">PP</span>)<span class="kw">,</span> <span class="dt">C</span>) <span class="kw">--&gt;</span> det(<span class="dt">Det</span><span class="kw">,</span> <span class="dt">C</span>)<span class="kw">,</span> blank<span class="kw">,</span> n(<span class="dt">N</span><span class="kw">,</span> <span class="dt">C</span>)<span class="kw">,</span> blank<span class="kw">,</span> pp(<span class="dt">PP</span>)<span class="kw">.</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>vp(vp(<span class="dt">V</span><span class="kw">,</span> <span class="dt">NP</span>)<span class="kw">,</span> <span class="dt">C</span>) <span class="kw">--&gt;</span> v(<span class="dt">V</span><span class="kw">,</span> <span class="dt">C</span>)<span class="kw">,</span> blank<span class="kw">,</span> np(<span class="dt">NP</span><span class="kw">,</span> <span class="dt">_</span>)<span class="kw">.</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>vp(vp(<span class="dt">V</span><span class="kw">,</span> <span class="dt">NP</span><span class="kw">,</span> <span class="dt">PP</span>)<span class="kw">,</span> <span class="dt">C</span>) <span class="kw">--&gt;</span> v(<span class="dt">V</span><span class="kw">,</span> <span class="dt">C</span>)<span class="kw">,</span> blank<span class="kw">,</span> np(<span class="dt">NP</span><span class="kw">,</span> <span class="dt">_</span>)<span class="kw">,</span> blank<span class="kw">,</span> pp(<span class="dt">PP</span>)<span class="kw">.</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>pp(pp(<span class="dt">P</span><span class="kw">,</span> <span class="dt">NP</span>)) <span class="kw">--&gt;</span> p(<span class="dt">P</span>)<span class="kw">,</span> blank<span class="kw">,</span> np(<span class="dt">NP</span><span class="kw">,</span> <span class="dt">_</span>)<span class="kw">.</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a><span class="co">% Determiners, personal nouns, nouns, verbs and participles</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>det(det(a)<span class="kw">,</span> sg) <span class="kw">--&gt;</span> <span class="st">`</span><span class="er">a</span><span class="st">`</span><span class="kw">.</span></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>det(det(the)<span class="kw">,</span> <span class="dt">_</span>) <span class="kw">--&gt;</span> <span class="st">`</span><span class="er">the</span><span class="st">`</span><span class="kw">.</span></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>pn(pn(john)<span class="kw">,</span> sg) <span class="kw">--&gt;</span> <span class="st">`</span><span class="er">john</span><span class="st">`</span><span class="kw">.</span></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>n(n(man)<span class="kw">,</span> sg) <span class="kw">--&gt;</span> <span class="st">`</span><span class="er">man</span><span class="st">`</span><span class="kw">.</span></span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>n(n(men)<span class="kw">,</span> pl) <span class="kw">--&gt;</span> <span class="st">`</span><span class="er">men</span><span class="st">`</span><span class="kw">.</span></span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>n(n(telescope)<span class="kw">,</span> sg) <span class="kw">--&gt;</span> <span class="st">`</span><span class="er">telescope</span><span class="st">`</span><span class="kw">.</span></span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>v(v(sees)<span class="kw">,</span> sg) <span class="kw">--&gt;</span> <span class="st">`</span><span class="er">sees</span><span class="st">`</span><span class="kw">.</span></span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a>v(v(see)<span class="kw">,</span> pl) <span class="kw">--&gt;</span> <span class="st">`</span><span class="er">see</span><span class="st">`</span><span class="kw">.</span></span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>v(v(saw)<span class="kw">,</span> <span class="dt">_</span>) <span class="kw">--&gt;</span> <span class="st">`</span><span class="er">saw</span><span class="st">`</span><span class="kw">.</span></span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a>p(p(with)) <span class="kw">--&gt;</span> <span class="st">`</span><span class="er">with</span><span class="st">`</span><span class="kw">.</span></span></code></pre></div>
<dl>
<dt>Listing 2</dt>
<dd>Simple grammar and lexicon. <code>sentence/2</code> preprocesses the R call.
</dd>
</dl>
<p>As in the first example, we first consult a little Prolog program with a minimalistic grammar and lexicon (Listing 2), and then raise a query asking for the syntactic structure of “john saw a man with a telescope”. Closer inspection of the two results reveals the two possible meanings, “john saw a man <em>who carries</em> a telescope” versus “john saw a man <em>through</em> a telescope”. More Prolog examples of natural language processing are found in Blackburn and Bos <span class="citation">(Blackburn and Bos 2005)</span>, including the resolution of anaphoric references and the extraction of semantic meaning.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># [telescope].</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="fu">consult</span>(<span class="fu">system.file</span>(<span class="fu">file.path</span>(<span class="st">&quot;pl&quot;</span>, <span class="st">&quot;telescope.pl&quot;</span>), <span class="at">package=</span><span class="st">&quot;rolog&quot;</span>))</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="co"># findall(sentence(Tree, &quot;john saw a man with a telescope&quot;)).</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="fu">findall</span>(<span class="fu">call</span>(<span class="st">&quot;sentence&quot;</span>, <span class="fu">expression</span>(Tree), <span class="st">&quot;john saw a man with a telescope&quot;</span>))</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [[1]]</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [[1]]$Tree</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; s(pn(john), vp(v(saw), np(det(a), n(man), pp(p(with), np(det(a), </span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;     n(telescope))))))</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [[2]]</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [[2]]$Tree</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; s(pn(john), vp(v(saw), np(det(a), n(man)), pp(p(with), np(det(a), </span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;     n(telescope)))))</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; attr(,&quot;query&quot;)</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] &quot;sentence(Tree, john saw a man with a telescope)&quot;</span></span></code></pre></div>
</div>
<div id="installation-of-add-ons-for-prolog" class="section level2">
<h2>Installation of add-ons for Prolog</h2>
<p>In description of the previous example, I noted in passing that rolog can use the built-in libraries of SWI-Prolog (e.g., by calls to <code>use_module/1</code>). It is also possible to extend the installation by add-ons, including add-ons that require compilation, if the build tools (essentially, RTools) are properly configured. This is illustrated below by the demo add-on “environ” <span class="citation">(J. Wielemaker 2012)</span> that collects the current environment variables.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co"># pack_install(environ, [interactive(false)]).</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="fu">once</span>(<span class="fu">call</span>(<span class="st">&quot;pack_install&quot;</span>, <span class="fu">as.name</span>(<span class="st">&quot;environ&quot;</span>), <span class="fu">list</span>(<span class="fu">call</span>(<span class="st">&quot;interactive&quot;</span>, <span class="cn">FALSE</span>))))</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="co"># use_module(library(environ))</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="fu">once</span>(<span class="fu">call</span>(<span class="st">&quot;use_module&quot;</span>, <span class="fu">call</span>(<span class="st">&quot;library&quot;</span>, <span class="fu">quote</span>(environ))))</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="co"># environ(X)</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="fu">once</span>(<span class="fu">call</span>(<span class="st">&quot;environ&quot;</span>, <span class="fu">expression</span>(X)))</span></code></pre></div>
<p>The query then unifies <em>X</em> with a list with Key=Value terms. The purpose if this example is obviously not to mimick the built-in function <code>Sys.getenv()</code> from R, but to illustrate the installation and usage of Prolog extensions from within R.</p>
</div>
<div id="term-manipulation" class="section level2">
<h2>Term manipulation</h2>
<p>Prolog is homoiconic, that is, code is data. In this example, we make use of Prolog’s ability to match expressions against given patterns and modify these expressions according to a few predefined “buggy rules” <span class="citation">(Brown and Burton 1978)</span>, inspired by recurrent mistakes in the statistics exams of my students. Consider the <span class="math inline">\(t\)</span>-statistic for comparing an observed group average to a population mean:</p>
<p><span class="math display">\[
T = \frac{\overline{X} - \mu}{s / \sqrt{N}}
\]</span></p>
<p>Some mistakes may occur in this calculation, for example, omission of the implicit parentheses around the numerator and the denominator when typing the numbers into a calculator, resulting to <span class="math inline">\(\overline{X} - \frac{\mu}{s} \div \sqrt{N}\)</span>, or forgetting the square root around <span class="math inline">\(N\)</span>, or both. Prolog code for the two buggy rules is given in Listing 3.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">% Correct step from task to solution</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>expert(tratio(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Mu</span><span class="kw">,</span> <span class="dt">S</span><span class="kw">,</span> <span class="dt">N</span>)<span class="kw">,</span> frac(<span class="dt">X</span> <span class="fu">-</span> <span class="dt">Mu</span><span class="kw">,</span> <span class="dt">S</span> <span class="fu">/</span> sqrt(<span class="dt">N</span>)))<span class="kw">.</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="co">% Mistakes</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>buggy(frac(<span class="dt">X</span> <span class="fu">-</span> <span class="dt">Mu</span><span class="kw">,</span> <span class="dt">S</span> <span class="fu">/</span> <span class="dt">SQRTN</span>)<span class="kw">,</span> <span class="dt">X</span> <span class="fu">-</span> frac(<span class="dt">Mu</span><span class="kw">,</span> <span class="dt">S</span>) <span class="fu">/</span> <span class="dt">SQRTN</span>)<span class="kw">.</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>buggy(sqrt(<span class="dt">N</span>)<span class="kw">,</span> <span class="dt">N</span>)<span class="kw">.</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="co">% Apply expert and buggy rules</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>step(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>) <span class="kw">:-</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>    expert(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>)<span class="kw">.</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>step(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>) <span class="kw">:-</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>    buggy(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>)<span class="kw">.</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a><span class="co">% Enter expressions</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>step(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>) <span class="kw">:-</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">compound</span>(<span class="dt">X</span>)<span class="kw">,</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>    mapargs(search<span class="kw">,</span> <span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>)<span class="kw">,</span></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>    dif(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>)<span class="kw">.</span></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a><span class="co">% Search through problem space</span></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a>search(<span class="dt">X</span><span class="kw">,</span> <span class="dt">X</span>)<span class="kw">.</span></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a>search(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Z</span>) <span class="kw">:-</span></span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a>    step(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>)<span class="kw">,</span></span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a>    search(<span class="dt">Y</span><span class="kw">,</span> <span class="dt">Z</span>)<span class="kw">.</span></span></code></pre></div>
<dl>
<dt>Listing 3</dt>
<dd>Manipulating terms in Prolog
</dd>
</dl>
<p>The little e-learning system shown in Listing 2 (<code>buggy.pl</code>) is invoked using the R script below.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(rolog)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="fu">consult</span>(<span class="fu">system.file</span>(<span class="fu">file.path</span>(<span class="st">&quot;pl&quot;</span>, <span class="st">&quot;buggy.pl&quot;</span>), <span class="at">package=</span><span class="st">&quot;rolog&quot;</span>))</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>q <span class="ot">&lt;-</span> <span class="fu">quote</span>(<span class="fu">search</span>(<span class="fu">tratio</span>(x, mu, s, n), .S))</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="fu">findall</span>(<span class="fu">as.rolog</span>(q))</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [[1]]</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [[1]]$S</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; tratio(x, mu, s, n)</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [[2]]</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [[2]]$S</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; frac(x - mu, s/sqrt(n))</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [[3]]</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [[3]]$S</span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; x - frac(mu, s)/sqrt(n)</span></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [[4]]</span></span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [[4]]$S</span></span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; x - frac(mu, s)/n</span></span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [[5]]</span></span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [[5]]$S</span></span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; frac(x - mu, s/n)</span></span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [[6]]</span></span>
<span id="cb20-33"><a href="#cb20-33" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [[6]]$S</span></span>
<span id="cb20-34"><a href="#cb20-34" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; x - frac(mu, s)/n</span></span>
<span id="cb20-35"><a href="#cb20-35" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb20-36"><a href="#cb20-36" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb20-37"><a href="#cb20-37" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; attr(,&quot;query&quot;)</span></span>
<span id="cb20-38"><a href="#cb20-38" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] &quot;search(tratio(x, mu, s, n), S)&quot;</span></span></code></pre></div>
<p>The fourth and the sixth result are combinations of the two buggy rules (parenthesis, then square root, and the other way round). Some additional filters would be needed to eliminate trivial and redundant solutions <span class="citation">(see, e.g., the chapter on generate-and-test in Sterling and Shapiro 1994)</span>.</p>
<p>It should be mentioned that R is homoiconic, too, and the Prolog code above can, in principle, be rewritten in R using non-standard evaluation techniques <span class="citation">(Wickham 2019)</span>. Prolog’s inbuilt pattern matching algorithm simplifies things a lot, though. An important feature of such a term manipulation is that the evaluation of the term can be postponed; for example, there is no need to instantiate the variables <code>X</code>, <code>Mu</code>, <code>s</code> and <code>N</code> with given values before raising a query. This is especially helpful for variables that may represent larger sets of data in the later course.</p>
</div>
<div id="rendering-mathematical-expressions" class="section level2">
<h2>Rendering mathematical expressions</h2>
<p>The R extension of the markdown language <span class="citation">(Xie, Dervieux, and Riederer 2020)</span> enables reproducible statistical reports with nice typesetting in HTML, Microsoft Word, and Latex. However, so far, R expressions such as <code>pbinom(k, N, p)</code> are typeset as-is; prettier mathematical expressions such as <span class="math inline">\(P_\mathrm{Bi}(X \le k; N, p)\)</span> require Latex commands like <code>P_\mathrm{Bi}\left(X \le k; N, p\right)</code>, which are cumbersome to type in and hard to read even if the expressions are simple. Since recently, manual pages include support for mathematical expressions <span class="citation">(Sarkar and Hornik 2022)</span>, which already is a big improvement.</p>
<p>Below Prolog’s grammar rules are used for an <em>automatic</em> translation of R expressions to MathML. The result can then be used for calculations or it can be rendered on a web page. A limited set of rules for translation from R to MathML is found in <code>pl/mathml.pl</code> of the rolog package. The relevant code snippets are shown in the listings below, along with their output.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(rolog)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="fu">consult</span>(<span class="fu">system.file</span>(<span class="fu">file.path</span>(<span class="st">&quot;pl&quot;</span>, <span class="st">&quot;mathml.pl&quot;</span>), <span class="at">package=</span><span class="st">&quot;rolog&quot;</span>))</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="co"># R interface to Prolog predicate r2mathml/2</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>mathml <span class="ot">=</span> <span class="cf">function</span>(term)</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>  t <span class="ot">=</span> <span class="fu">once</span>(<span class="fu">call</span>(<span class="st">&quot;r2mathml&quot;</span>, term, <span class="fu">expression</span>(X)))</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">cat</span>(<span class="fu">paste</span>(t<span class="sc">$</span>X, <span class="at">collapse=</span><span class="st">&quot;&quot;</span>))</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<dl>
<dt>Listing 4</dt>
<dd>Using rolog to generate MathML from R expressions
</dd>
</dl>
<p>The first example is easy. At the Prolog end, there is a handler for <code>pbinom/3</code> that translates the term into a pretty MathML syntax like P_bi(X &lt;= k; N, pi).</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>term <span class="ot">=</span> <span class="fu">quote</span>(<span class="fu">pbinom</span>(k, N, p))</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Pretty print</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="fu">mathml</span>(term)</span></code></pre></div>
<p><math><mrow><msub><mi>P</mi><mtext>Bi</mtext></msub><mo>⁡</mo><mrow><mo>(</mo><mrow><mrow><mi>X</mi><mo>≤</mo><mi>k</mi></mrow><mo>;</mo><mrow><mi>N</mi><mo>,</mo><mi>p</mi></mrow></mrow><mo>)</mo></mrow></mrow></math></p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Do some calculations with the same term</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>k <span class="ot">=</span> <span class="dv">10</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>N <span class="ot">=</span> <span class="dv">22</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>p <span class="ot">=</span> <span class="fl">0.4</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="fu">eval</span>(term)</span></code></pre></div>
<p>[1] 0.77195</p>
<p>The next example is interesting because Prolog needs find out the name of the integration variable for <code>sin</code>. For that purpose, rolog provides a predicate <code>r_eval/2</code> that calls R from Prolog (i.e., the reverse direction, see also next example). Here, the predicate is used for the R function <code>formalArgs(args(sin))</code>, which returns the name of the function argument of <code>sin</code>, that is, <code>x</code>.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>term <span class="ot">=</span> <span class="fu">quote</span>(<span class="fu">integrate</span>(sin, 0L, 2L<span class="sc">*</span>pi))</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="fu">mathml</span>(term)</span></code></pre></div>
<p><math><mrow><munderover><mo>∫</mo><mn>0</mn><mrow><mn>2</mn><mo>⁢</mo><mi>π</mi></mrow></munderover><mrow><mi>sin</mi><mo>⁡</mo><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow><mspace width="thinmathspace"></mspace><mi>d</mi><mi>x</mi></mrow></math></p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="fu">eval</span>(term)</span></code></pre></div>
<p>2.221482e-16 with absolute error &lt; 4.4e-14</p>
<p>Note that the Prolog end, the handler for <code>integrate/3</code> is rather rigid; it accepts only these three arguments in that particular order, and without names, that is, <code>integrate(sin, lower=0L, upper=2L * pi)</code> would not print the desired result.</p>
<p>Therefore, <code>pl/mathml.pl</code> includes two handlers that accept terms with named arguments, <code>integrate(f=Fn, lower=Lower, upper=Upper)</code>, as well as terms of the form <code>$(integrate(Fn, Lower, Upper), value)</code> that are needed for the evaluation below.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply match.call to all components of a term</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>canonical <span class="ot">&lt;-</span> <span class="cf">function</span>(term)</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">is.call</span>(term))</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    f <span class="ot">&lt;-</span> <span class="fu">match.fun</span>(term[[<span class="dv">1</span>]])</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is.primitive</span>(f))</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>      term <span class="ot">&lt;-</span> <span class="fu">match.call</span>(f, term)</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Recurse into arguments</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>    term[<span class="sc">-</span><span class="dv">1</span>] <span class="ot">&lt;-</span> <span class="fu">lapply</span>(term[<span class="sc">-</span><span class="dv">1</span>], canonical)</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(term)</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a><span class="co"># A custom function</span></span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a>g <span class="ot">&lt;-</span> <span class="cf">function</span>(u)</span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sin</span>(u)</span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-23"><a href="#cb26-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Mixture of (partially) named and positional arguments in unusual order</span></span>
<span id="cb26-24"><a href="#cb26-24" aria-hidden="true" tabindex="-1"></a>term <span class="ot">&lt;-</span> <span class="fu">quote</span>(2L <span class="sc">*</span> <span class="fu">integrate</span>(<span class="at">low=</span><span class="sc">-</span><span class="cn">Inf</span>, <span class="at">up=</span><span class="cn">Inf</span>, g)<span class="sc">$</span>value)</span>
<span id="cb26-25"><a href="#cb26-25" aria-hidden="true" tabindex="-1"></a><span class="fu">mathml</span>(<span class="fu">canonical</span>(term))</span></code></pre></div>
<p><math><mrow><mn>2</mn><mo>⋅</mo><mrow><munderover><mo>∫</mo><mrow><mo>-</mo><mi>∞</mi></mrow><mi>∞</mi></munderover><mrow><mi>g</mi><mo>⁡</mo><mrow><mo>(</mo><mi>u</mi><mo>)</mo></mrow></mrow><mspace width="thinmathspace"></mspace><mi>d</mi><mi>u</mi></mrow></mrow></math></p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="co"># It is a bit of a mystery that R knows the result of this integral.</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="fu">eval</span>(term)</span></code></pre></div>
<p>[1] 0</p>
<p>The extra R function <code>canonical()</code> applies <code>match.call()</code> to non-primitive R calls, basically cleaning up the arguments and bringing them into the correct order.</p>
</div>
<div id="calling-prolog-from-r" class="section level2">
<h2>Calling Prolog from R</h2>
<p>The basic workflow of the bridge from R to Prolog is to (A) translate an R expression into a Prolog term (i.e., a predicate), (B) query the predicate, and then, (C) translate the result (i.e., the bindings of the variables) back to R. The reverse direction is straightforward, we start by translating a Prolog term to an R expression (i.e. Step C), evaluate the R expression, and then translate the result back to a Prolog term (Step A). Rolog provides two Prolog predicates for this purpose, <code>r_eval(Expr)</code> and <code>r_eval(Expr, Res)</code>. The former is used to invoke an R expression <em>Expr</em> for its side effects (e.g., initializing a random number generator); it does not return a result. The latter is used to evaluate the R expression <em>Expr</em> and return the result <em>Res</em>. The code snippet in Listing 5 (<code>r_eval.pl</code>) illustrates this behavior.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>r_seed(<span class="dt">Seed</span>) <span class="kw">:-</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    r_eval(<span class="st">&#39;</span><span class="er">set</span><span class="st">.</span><span class="er">seed</span><span class="st">&#39;</span>(<span class="dt">Seed</span>))<span class="kw">.</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>r_norm(<span class="dt">N</span><span class="kw">,</span> <span class="dt">L</span>) <span class="kw">:-</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    r_eval(rnorm(<span class="dt">N</span>)<span class="kw">,</span> <span class="dt">L</span>)<span class="kw">.</span></span></code></pre></div>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co"># [r_eval].</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="fu">consult</span>(<span class="fu">system.file</span>(<span class="fu">file.path</span>(<span class="st">&quot;pl&quot;</span>, <span class="st">&quot;r_eval.pl&quot;</span>), <span class="at">package=</span><span class="st">&quot;rolog&quot;</span>))</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span class="co"># rnorm(3)</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a><span class="fu">once</span>(<span class="fu">call</span>(<span class="st">&quot;r_norm&quot;</span>, 3L, <span class="fu">expression</span>(X)))</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; $X</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] -0.5604756 -0.2301775  1.5587083</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; attr(,&quot;query&quot;)</span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] &quot;r_norm(3, X)&quot;</span></span></code></pre></div>
<dl>
<dt>Listing 5</dt>
<dd>Calling Prolog from R using <code>r_eval/1</code> and <code>r_eval/2</code>. The R call <code>set.seed</code> is quoted because the dot is an operator in Prolog.
</dd>
</dl>
<p>The example in Listing 5 is a bit trivial, basically illustrating the syntax and the workflow. More serious applications of <code>r_eval/1,2</code> are illustrated in the example on mathematical expressions where <code>r_eval/2</code> is used to obtain a names of a function argument, as well as in the next example on interval arithmetic, where <code>r_eval/2</code> is used with monototonically behaving R functions.</p>
</div>
<div id="interval-arithmetic" class="section level2">
<h2>Interval arithmetic</h2>
<p>Let <span class="math inline">\(\langle\ell, u\rangle\)</span> denote a number between <span class="math inline">\(\ell\)</span> and <span class="math inline">\(u\)</span>, <span class="math inline">\(\ell\le u\)</span>. It is easily verified that the result of the difference <span class="math inline">\(\langle\ell_1, u_1\rangle - \langle\ell_2, u_2\rangle\)</span> is somewhere in the interval <span class="math inline">\(\langle \ell_1 - u_2, u_1 - \ell_2\rangle\)</span>, and a number of rules exist for basic arithmetic operations and (piecewise) monotonically behaving functions <span class="citation">(Hickey, Ju, and Emden 2001)</span>. For ratios, denominators with mixed sign yield two possible intervals, for example, <span class="math inline">\(\langle 1, 2\rangle / \langle -3, 3\rangle = \langle -\infty, 3\rangle \cup \langle 3, \infty\rangle\)</span>, as shown in Figure 4 in Hickey et al.’s article. The number of possible candidates increases if more complicated functions are involved, as unions of intervals themselves appear as arguments (e.g., if <span class="math inline">\(I_1 \cup I_2\)</span> is added to <span class="math inline">\(I_3 \cup I_4\)</span>, the result is <span class="math inline">\(I_1 + I_3 \cup I_1 + I_4 \cup I_2 + I_3 \cup I_2 + I_4\)</span>). As a consequence, calculations in interval arithmetic are non-deterministic in nature, and the number of possible results is not foreseeable and cannot, in general, be vectorized as is often done in R. Use cases for interval arithmetic are the limitations of floating-point representations in computer hardware, but intervals can also be used to represent the result of measurements with limited precision, or truncated intermediate results of students doing hand calculations. A few rules for basic interval arithmetic are found in <code>pl/interval.pl</code>; a few examples are shown below. Again, Prolog rings back to R via <code>r_eval/2</code> to determine the result of <code>dbinom(X, Size, Prob, Log)</code>.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co"># [interval].</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="fu">consult</span>(<span class="fu">system.file</span>(<span class="fu">file.path</span>(<span class="st">&quot;pl&quot;</span>, <span class="st">&quot;interval.pl&quot;</span>), <span class="at">package=</span><span class="st">&quot;rolog&quot;</span>))</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="co"># findall(1 ... 2 / -3 ... 3, Res).</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>q <span class="ot">&lt;-</span> <span class="fu">quote</span>(<span class="fu">int</span>(<span class="st">`</span><span class="at">...</span><span class="st">`</span>(<span class="dv">1</span>, <span class="dv">2</span>) <span class="sc">/</span> <span class="st">`</span><span class="at">...</span><span class="st">`</span>(<span class="sc">-</span><span class="dv">3</span>, <span class="dv">3</span>), .Res))</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a><span class="fu">findall</span>(<span class="fu">as.rolog</span>(q))</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [[1]]</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [[1]]$Res</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; ...(-Inf, -0.333333333333333)</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [[2]]</span></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [[2]]$Res</span></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; ...(0.333333333333333, Inf)</span></span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; attr(,&quot;query&quot;)</span></span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] &quot;int(1.0...2.0/(- 3.0)...3.0, Res)&quot;</span></span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true" tabindex="-1"></a><span class="co"># t-ratio</span></span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true" tabindex="-1"></a>D  <span class="ot">=</span> <span class="fu">quote</span>(<span class="st">`</span><span class="at">...</span><span class="st">`</span>(<span class="fl">5.7</span>, <span class="fl">5.8</span>))</span>
<span id="cb30-23"><a href="#cb30-23" aria-hidden="true" tabindex="-1"></a>mu <span class="ot">=</span> <span class="dv">4</span></span>
<span id="cb30-24"><a href="#cb30-24" aria-hidden="true" tabindex="-1"></a>s  <span class="ot">=</span> <span class="fu">quote</span>(<span class="st">`</span><span class="at">...</span><span class="st">`</span>(<span class="fl">3.8</span>, <span class="fl">3.9</span>))</span>
<span id="cb30-25"><a href="#cb30-25" aria-hidden="true" tabindex="-1"></a>N  <span class="ot">=</span> 24L</span>
<span id="cb30-26"><a href="#cb30-26" aria-hidden="true" tabindex="-1"></a>tratio <span class="ot">=</span> <span class="fu">call</span>(<span class="st">&quot;/&quot;</span>, <span class="fu">call</span>(<span class="st">&quot;-&quot;</span>, D, mu), <span class="fu">call</span>(<span class="st">&quot;/&quot;</span>, s, <span class="fu">call</span>(<span class="st">&quot;sqrt&quot;</span>, N)))</span>
<span id="cb30-27"><a href="#cb30-27" aria-hidden="true" tabindex="-1"></a><span class="fu">findall</span>(<span class="fu">call</span>(<span class="st">&quot;int&quot;</span>, tratio, <span class="fu">expression</span>(Res)))</span>
<span id="cb30-28"><a href="#cb30-28" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; list()</span></span>
<span id="cb30-29"><a href="#cb30-29" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; attr(,&quot;query&quot;)</span></span>
<span id="cb30-30"><a href="#cb30-30" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] &quot;int((5.7...5.8-4.0)/(3.8...3.9/sqrt(24)), Res)&quot;</span></span>
<span id="cb30-31"><a href="#cb30-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-32"><a href="#cb30-32" aria-hidden="true" tabindex="-1"></a><span class="co"># Binomial density</span></span>
<span id="cb30-33"><a href="#cb30-33" aria-hidden="true" tabindex="-1"></a>prob <span class="ot">=</span> <span class="fu">quote</span>(<span class="st">`</span><span class="at">...</span><span class="st">`</span>(<span class="fl">0.2</span>, <span class="fl">0.3</span>))</span>
<span id="cb30-34"><a href="#cb30-34" aria-hidden="true" tabindex="-1"></a><span class="fu">once</span>(<span class="fu">call</span>(<span class="st">&quot;int&quot;</span>, <span class="fu">call</span>(<span class="st">&quot;dbinom&quot;</span>, 4L, 10L, prob, <span class="cn">FALSE</span>), <span class="fu">expression</span>(Res)))</span>
<span id="cb30-35"><a href="#cb30-35" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; $Res</span></span>
<span id="cb30-36"><a href="#cb30-36" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; ...(0.088080384, 0.200120949)</span></span>
<span id="cb30-37"><a href="#cb30-37" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb30-38"><a href="#cb30-38" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; attr(,&quot;query&quot;)</span></span>
<span id="cb30-39"><a href="#cb30-39" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] &quot;int(dbinom(4, 10, 0.2...0.3, false), Res)&quot;</span></span>
<span id="cb30-40"><a href="#cb30-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-41"><a href="#cb30-41" aria-hidden="true" tabindex="-1"></a>prob <span class="ot">=</span> <span class="fu">quote</span>(<span class="st">`</span><span class="at">...</span><span class="st">`</span>(<span class="fl">0.5</span>, <span class="fl">0.6</span>))</span>
<span id="cb30-42"><a href="#cb30-42" aria-hidden="true" tabindex="-1"></a><span class="fu">once</span>(<span class="fu">call</span>(<span class="st">&quot;int&quot;</span>, <span class="fu">call</span>(<span class="st">&quot;dbinom&quot;</span>, 4L, 10L, prob, <span class="cn">FALSE</span>), <span class="fu">expression</span>(Res)))</span>
<span id="cb30-43"><a href="#cb30-43" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; $Res</span></span>
<span id="cb30-44"><a href="#cb30-44" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; ...(0.111476736, 0.205078125)</span></span>
<span id="cb30-45"><a href="#cb30-45" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb30-46"><a href="#cb30-46" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; attr(,&quot;query&quot;)</span></span>
<span id="cb30-47"><a href="#cb30-47" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] &quot;int(dbinom(4, 10, 0.5...0.6, false), Res)&quot;</span></span>
<span id="cb30-48"><a href="#cb30-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-49"><a href="#cb30-49" aria-hidden="true" tabindex="-1"></a>prob <span class="ot">=</span> <span class="fu">quote</span>(<span class="st">`</span><span class="at">...</span><span class="st">`</span>(<span class="fl">0.2</span>, <span class="fl">0.6</span>))</span>
<span id="cb30-50"><a href="#cb30-50" aria-hidden="true" tabindex="-1"></a><span class="fu">once</span>(<span class="fu">call</span>(<span class="st">&quot;int&quot;</span>, <span class="fu">call</span>(<span class="st">&quot;dbinom&quot;</span>, 4L, 10L, prob, <span class="cn">FALSE</span>), <span class="fu">expression</span>(Res)))</span>
<span id="cb30-51"><a href="#cb30-51" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; $Res</span></span>
<span id="cb30-52"><a href="#cb30-52" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; ...(0.088080384, 0.250822656)</span></span>
<span id="cb30-53"><a href="#cb30-53" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb30-54"><a href="#cb30-54" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; attr(,&quot;query&quot;)</span></span>
<span id="cb30-55"><a href="#cb30-55" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] &quot;int(dbinom(4, 10, 0.2...0.6, false), Res)&quot;</span></span></code></pre></div>
<p>The slightly cumbersome syntax for entering an interval <span class="math inline">\(\langle \ell, u\rangle\)</span> is due to the fact that the ellipsis is a reserved symbol in R and cannot be used as an infix operator. A way more powerful and comprehensive system for constraint logic programming over intervals is available as a Prolog pack <span class="citation">(Workman 2021)</span> and can easily be connected to R using, for example, the present package.</p>
</div>
</div>
<div id="conclusions" class="section level1">
<h1>5. Conclusions</h1>
<p>R has become the primary language for statistical programming and data science, but is currently lacking support for traditional, symbolic artificial intelligence. There are already two add-ons for SWI-Prolog that allow to run R calculations from Prolog <span class="citation">(Angelopoulos et al. 2013; Jan Wielemaker 2021)</span>, but a connection in the other direction was missing, so far. rolog bridges this gap by providing an interface to a SWI-Prolog distribution embedded into an R package. The communication between the two systems is mainly in the form of queries from R to Prolog, but two Prolog predicates allow Prolog to ring back and evaluate terms in R. The design of the package is minimalistic, providing three main functions <code>query(...)</code>, <code>submit()</code>, and <code>clear()</code>, and a very limited set of convenience tools (<code>consult(...)</code>, <code>once(...)</code>, and <code>findall(...)</code>) to facilitate everyday actions. As both systems are homoiconic in nature, it was easy to establish a one-to-one correspondence between the elements of the two languages. Most exceptions (e.g., lack of R support for empty symbols) can be avoided and/or circumvented by wrapper functions at both ends.</p>
<p>Simple ways to extend the package have been described in Section 3; such extensions could, for example, include R objects and structures like those returned by <code>lm</code>, or S4 classes. In many use cases, this may be realized by transforming the R object to a list with named elements, and “reconstruct” the object on the Prolog end if needed. After a query, the process is reversed. If speed is an issue, more of these steps can, in principle, be moved into the package and implemented in Rcpp.</p>
<p>rolog, thus, opens up a wide of applications in logic programming for statisticians and researchers at the intersection of symbolic and connectionist artificial intelligence, where concise knowledge representation is combined with statistical power. Moreover, rolog provides starting points for useful small-scale solutions for everyday issues in data science (term transformations, pretty mathematical output, interval arithmetic).</p>
<p>At its present stage, a major limitation of rolog is its rather slow speed. For example, translation of R lists or vectors to the respective elements of the Prolog language (lists, <code>#/N</code>) is done element-wise, in both directions. The translation is optimized using Rcpp <span class="citation">(Eddelbuettel and Balamuta 2018)</span>, but there remains an upper bound in the efficiency, because Prolog does not support vectors or matrices. Of course, Prolog’s primary purpose is not vector or matrix calculation, so this limitation may not show up in real-world applications. Another issue, maybe a bit annoying, is the rather cumbersome syntax of the interface, with the need for quoted calls and R expressions being a bit misused for representing Prolog variables. rolog was deliberately chosen to be minimalistic and, so far, only depends on base R. A more concise form of representation might be obtained by tools from the “Tidyverse” ecosystem, as described in Chapter 19 of Advanced R <span class="citation">(Wickham 2019)</span>. Finally, at this stage, rolog is unable to deal with cyclic Prolog terms (e.g., <code>once(call(&quot;=&quot;, expression(A), call(&quot;f&quot;, expression(A))))</code> raises an error message).</p>
<p>rolog is available for R version 4.2 and later. The source code of the package is found at <a href="https://github.com/mgondan/rolog/" class="uri">https://github.com/mgondan/rolog/</a>, including installation instructions for Unix, Windows and macOS.</p>
</div>
<div id="acknowledgement" class="section level1">
<h1>Acknowledgement</h1>
<p>I am grateful to Jan Wielemaker, the main developer of SWI-Prolog; this package would never have been finalized without his help. Moreover, development of the package profited substantially from the Prolog packs rserve_client <span class="citation">(Jan Wielemaker 2021)</span> and real <span class="citation">(Angelopoulos et al. 2013)</span>. The project was financially supported by the European Commission (Erasmus+ project QHelp, 2019-1-EE01-KA203-051708).</p>
</div>
<div id="references" class="section level1 unnumbered">
<h1 class="unnumbered">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-Angelopoulos2013" class="csl-entry">
Angelopoulos, Nicos, Vitor Santos Costa, Joao Azevedo, Jan Wielemaker, Rui Camacho, and Lodewyk Wessels. 2013. <span>“Integrative Functional Statistics in Logic Programming.”</span> In <em>Proceedings of Practical Aspects of Declarative Languages</em>, 7752:190–205. LNCS. Rome, Italy.
</div>
<div id="ref-Angelopoulos2008" class="csl-entry">
Angelopoulos, Nicos, and James Cussens. 2008. <span>“Bayesian Learning of Bayesian Networks with Informative Priors.”</span> <em>Journal of Annals of Mathematics and Artificial Intelligence</em> 54: 53–98.
</div>
<div id="ref-YapR" class="csl-entry">
Azevedo, J. 2011. <em>YapR</em>. <a href="https://github.com/jcazevedo/YapR">https://github.com/jcazevedo/YapR</a>.
</div>
<div id="ref-ggdag" class="csl-entry">
Barrett, Malcolm. 2021. <em>Ggdag: Analyze and Create Elegant Directed Acyclic Graphs</em>. <a href="https://CRAN.R-project.org/package=ggdag">https://CRAN.R-project.org/package=ggdag</a>.
</div>
<div id="ref-Blackburn2005" class="csl-entry">
Blackburn, P., and J. Bos. 2005. <em>Representation and Inference for Natural Language. A First Course in Computational Semantics</em>. Stanford: CSLI.
</div>
<div id="ref-Brown1978" class="csl-entry">
Brown, J. S., and R. R. Burton. 1978. <span>“Diagnostic Models for Procedural Bugs in Basic Mathematical Skills.”</span> <em>Cognitive Science</em> 2: 155–92.
</div>
<div id="ref-Carro2004" class="csl-entry">
Carro, Manuel. 2004. <span>“An Application of Rational Trees in a Logic Programming Interpreter for a Procedural Language.”</span> Technical University of Madrid: School of ComputerScience.
</div>
<div id="ref-Colmerauer1996" class="csl-entry">
Colmerauer, Alain, and Philippe Roussel. 1996. <span>“History of Programming Languages—II.”</span> In, edited by Thomas J. Bergin Jr. and Richard G. Gibson Jr., 331–67. New York, NY, USA: ACM.
</div>
<div id="ref-Cussens2000" class="csl-entry">
Cussens, James. 2000. <span>“Sixteenth Annual Conference on Uncertainty in Artificial Intelligence (UAI’00).”</span> In, edited by Thomas J. Bergin Jr. and Richard G. Gibson Jr., 115–22. San Francisco, CA.
</div>
<div id="ref-Dahl1981" class="csl-entry">
Dahl, V. 1981. <span>“Translating Spanish into Logic Through Logic.”</span> <em>American Journal of Computational Linguistics</em> 7 (3): 149–64.
</div>
<div id="ref-Edelbuettel2018" class="csl-entry">
Eddelbuettel, Dirk, and James Joseph Balamuta. 2018. <span>“<span class="nocase">Extending R with C++: A Brief Introduction to Rcpp</span>.”</span> <em>The American Statistician</em> 72 (1): 28–36. <a href="https://doi.org/10.1080/00031305.2017.1375990">https://doi.org/10.1080/00031305.2017.1375990</a>.
</div>
<div id="ref-Fruehwirth1998" class="csl-entry">
Frühwirth, T. 1998. <span>“Theory and Practice of Constraint Handling Rules.”</span> <em>Journal of Logic Programming</em> 37: 95–138.
</div>
<div id="ref-greenland1999" class="csl-entry">
Greenland, S., J. Pearl, and J. M. Robins. 1999. <span>“Causal Diagrams for Epidemiologic Research.”</span> <em>Epidemiology</em> 10: 37–48.
</div>
<div id="ref-Hickey2001" class="csl-entry">
Hickey, T., Q. Ju, and M. H. van Emden. 2001. <span>“Interval Arithmetic: From Principles to Implementation.”</span> <em>Journal of the ACM</em> 48: 1038–68.
</div>
<div id="ref-Hsiang1987" class="csl-entry">
Hsiang, Jieh, and Mandayam Srivas. 1987. <span>“Automatic Inductive Theorem Proving Using Prolog.”</span> <em>Theoretical Computer Science</em> 54 (1): 3–28.
</div>
<div id="ref-Lally2011" class="csl-entry">
Lally, Adam, and Paul Fodor. 2011. <span>“Natural Language Processing with Prolog in the IBM Watson System.”</span> In.
</div>
<div id="ref-Kimmig2011" class="csl-entry">
ProbLog, On the implementation of the probabilistic logic programming language. 2011. <span>“Angelika Kimmig and Bart Demoen and Luc de Raedt and Vítor Santos Costa and Ricardo Rocha.”</span> <em>Theory and Practice of Logic Programming</em> 11: 235–326.
</div>
<div id="ref-R" class="csl-entry">
R Core Team. 2021. <em>R: A Language and Environment for Statistical Computing</em>. Vienna, Austria: R Foundation for Statistical Computing. <a href="https://www.R-project.org/">https://www.R-project.org/</a>.
</div>
<div id="ref-Sarkar2022" class="csl-entry">
Sarkar, Deepayan, and Kurt Hornik. 2022. <em>Enhancements to <span>HTML</span> <span>D</span>ocumentation</em>. <a href="https://blog.r-project.org/2022/04/08/enhancements-to-html-documentation/index.html">https://blog.r-project.org/2022/04/08/enhancements-to-html-documentation/index.html</a>.
</div>
<div id="ref-Sato2001" class="csl-entry">
Sato, Taisuke, and Yoshitaka Kameya. 2013. <span>“Parameter Learning of Logic Programs for Symbolic Statistical Modeling.”</span> <em>Journal of AI Research</em> 15: 391–454.
</div>
<div id="ref-Shoham1994" class="csl-entry">
Shoham, Yoav. 1994. <em>Artificial Intelligence Techniques in Prolog</em>. San Francisco: Morgan Kaufman.
</div>
<div id="ref-Sterling1994" class="csl-entry">
Sterling, L., and E. Shapiro. 1994. <em>The Art of Prolog</em>. Cambridge: MIT Press.
</div>
<div id="ref-Triska2018" class="csl-entry">
Triska, Markus. 2018. <span>“Boolean Constraints in <span>SWI-Prolog</span>: A Comprehensive System Description.”</span> <em>Science of Computer Programming</em> 164: 98–115.
</div>
<div id="ref-Urbanek2021" class="csl-entry">
Urbanek, Simon. 2021. <em>Rserve: Binary r Server</em>. <a href="https://CRAN.R-project.org/package=Rserve">https://CRAN.R-project.org/package=Rserve</a>.
</div>
<div id="ref-Wickham2019" class="csl-entry">
Wickham, Hadley. 2019. <em>Advanced r</em>. London: Chapman &amp; Hall.
</div>
<div id="ref-Environ" class="csl-entry">
Wielemaker, J. 2012. <em>Demo Package with c Code, Fetching the Program Environment</em>. <a href="https://www.swi-prolog.org/pack/list?p=environ">https://www.swi-prolog.org/pack/list?p=environ</a>.
</div>
<div id="ref-Wielemaker2021" class="csl-entry">
———. 2021. <em>A c++ Interface to SWI-Prolog</em>. <a href="https://www.swi-prolog.org/pldoc/doc_for?object=section(%27packages/pl2cpp.html%27)">https://www.swi-prolog.org/pldoc/doc_for?object=section(%27packages/pl2cpp.html%27)</a>.
</div>
<div id="ref-Rserve" class="csl-entry">
Wielemaker, Jan. 2021. <em>Rserve Client for SWI-Prolog/SWISH</em>. <a href="https://github.com/JanWielemaker/rserve_client">https://github.com/JanWielemaker/rserve_client</a>.
</div>
<div id="ref-SWISH" class="csl-entry">
Wielemaker, Jan, Torbjörn Lager, and Fabrizio Riguzzi. 2015. <span>“<span>SWISH:</span> SWI-Prolog for Sharing.”</span> <em>CoRR</em> abs/1511.00915. <a href="https://arxiv.org/abs/1511.00915">https://arxiv.org/abs/1511.00915</a>.
</div>
<div id="ref-Wielemaker2012" class="csl-entry">
Wielemaker, Jan, Tom Schrijvers, Markus Triska, and Torbjörn Lager. 2012. <span>“SWI-Prolog.”</span> <em>Theory and Practice of Logic Programming</em> 12 (1-2): 67–96. <a href="https://doi.org/10.1017/S1471068411000494">https://doi.org/10.1017/S1471068411000494</a>.
</div>
<div id="ref-Workman2021" class="csl-entry">
Workman, R. 2021. <em>clpBNR. Von CLP over Reals Using Interval Arithmetic. Includes Rational, Integer and Boolean Domains as Subsets</em>. <a href="https://github.com/ridgeworks/clpBNR">https://github.com/ridgeworks/clpBNR</a>.
</div>
<div id="ref-Xie2020" class="csl-entry">
Xie, Y., C. Dervieux, and E. Riederer. 2020. <em>R Markdown Cookbook</em>. Cambridge: Chapman and Hall/CRC.
</div>
<div id="ref-Zinda2021" class="csl-entry">
Zinda, Eric. 2021. <em>Mqi – Python and Other Programming Languge Integration for SWI Prolog</em>. <a href="https://www.swi-prolog.org/pldoc/doc_for?object=section(%27packages/mqi.html%27)">https://www.swi-prolog.org/pldoc/doc_for?object=section(%27packages/mqi.html%27)</a>.
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>

<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Matthias Gondan (Department of Psychology, University of Innsbruck, Austria) and Jan Wielemaker (Vrije Universiteit Amsterdam/SWI-Prolog Solutions b.v.)" />

<meta name="date" content="2022-04-28" />

<title>rolog: Prolog queries from R</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>
<script>// Hide empty <a> tag within highlighted CodeBlock for screen reader accessibility (see https://github.com/jgm/pandoc/issues/6352#issuecomment-626106786) -->
// v0.0.1
// Written by JooYoung Seo (jooyoung@psu.edu) and Atsushi Yasumoto on June 1st, 2020.

document.addEventListener('DOMContentLoaded', function() {
  const codeList = document.getElementsByClassName("sourceCode");
  for (var i = 0; i < codeList.length; i++) {
    var linkList = codeList[i].getElementsByTagName('a');
    for (var j = 0; j < linkList.length; j++) {
      if (linkList[j].innerHTML === "") {
        linkList[j].setAttribute('aria-hidden', 'true');
      }
    }
  }
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>



<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">rolog: Prolog queries from R</h1>
<h4 class="author">Matthias Gondan (Department of Psychology, University of Innsbruck, Austria) and Jan Wielemaker (Vrije Universiteit Amsterdam/SWI-Prolog Solutions b.v.)</h4>
<h4 class="date">2022-04-28</h4>



<p>Matthias Gondan<br />
Department of Psychology<br />
University of Innsbruck<br />
Innrain 9<br />
A-6020 Innsbruck<br />
<a href="mailto:Matthias.Gondan-Rochon@uibk.ac.at" class="email">Matthias.Gondan-Rochon@uibk.ac.at</a></p>
<div id="abstract" class="section level1">
<h1>Abstract</h1>
<p>Prolog is a classical logic programming language with many applications in expert systems, computer linguistics and traditional, that is, symbolic artificial intelligence. The main strength of Prolog is its concise representation of facts and rules for the representation of knowledge and grammar, as well as its efficient built-in search engine for closed world domains. R is a statistical programming language for data analysis and statistical modeling which is widely used in academia and industry. Besides the core library, a lot of packages have been developed for all kinds of statistical problems, including statistics-based artificial intelligence tools such as neural networks for machine learning and deep learning. Whereas Prolog is weak in statistical computation, but strong in symbolic manipulation, the converse may be said for the R language. SWI-Prolog is a widely used Prolog system that offers a wide range of extensions for real world applications, and there already exist two Prolog “packs” to invoke R (<code>rserve-client</code>, <code>real</code>) from SWI-Prolog. Given the large user community of R, there may also be a need for a connection in the reverse direction that allows invoking Prolog queries in R computations. The R package <code>rolog</code> embeds the SWI-Prolog system, thus enabling deterministic and non-deterministic queries to the Prolog interpreter. Usage of <code>rolog</code> is illustrated by a few examples.</p>
<div id="keywords" class="section level2">
<h2>Keywords</h2>
<p>Statistics; Logic Programming; Artificial Intelligence; R; Prolog</p>
</div>
</div>
<div id="rolog-prolog-queries-from-r" class="section level1">
<h1>1. rolog: Prolog queries from R</h1>
<p>The R <span class="citation">(R Core Team 2021)</span> programming language and environment is a widely used open source software for statistical data analysis. The basic R is a functional language with lots of support for storage and manipulation of different data types, and a strong emphasis on operations involving vectors and arrays. Moreover, a huge number of packages (e.g., CRAN, <a href="https://cran.r-project.org/" class="uri">https://cran.r-project.org/</a>) have been contributed that cover problems from diverse areas such as bioinformatics, machine learning, specialized statistical methods, web programming and connections to other programming languages.</p>
<p>An interface to Prolog is lacking so far. Based on earlier work by Kowalski, the logic programming language Prolog was invented in the 1970ies by Colmerauer and Roussel <span class="citation">(Kowalski 1988)</span>, mostly for the purpose of natural language processing. Since then, logic programming has become an important driving force in research on artificial intelligence, natural language processing, program analysis, knowledge representation and theorem proving <span class="citation">(Shoham 1994; Lally and Fodor 2011; Carro 2004; Hsiang and Srivas 1987)</span>.<br />
SWI-Prolog <span class="citation">(Wielemaker et al. 2012)</span> is an open-source implementation of Prolog that mainly targets developers of applications, with many users in academia, research and industry. SWI-Prolog includes a large number of libraries for “the real world”, for example, a web server, encryption, interfaces to C/C++ and other programming languages, as well as a development environment and debugger. In addition, pluggable extensions (so-called packs) are available for specific tasks to enhance its capabilities.</p>
<p>Unlike R, Prolog is a declarative programming language consisting of facts and rules that define relations, for example, in a problem space <span class="citation">(Newell and Simon 1972)</span>. Prolog’s major strength is its built-in query-driven search engine that efficiently deals with complex structured data, with the data not necessarily being numerical. In fact, Prolog only provides a basic collection of arithmetic calculations via a purely functional interface (<code>is/2</code>). More complex calculations such as matrix algebra, statistical models or machine learning need help from other systems, for example, from R.</p>
<p>Angelopoulos et al. <span class="citation">(2013)</span> summarize work at the intersection of symbolic knowledge representation and statistical inference, especially in the area of model fits <span class="citation">(EM algorithms, MCMC, Sato and Kameya 2013; Angelopoulos and Cussens 2008)</span> and stochastic logic programs <span class="citation">(Cussens 2000; Kimmig et al. 2011)</span>. One of the major strengths of logic programming is handling constraints; and a number of systems for constraint satisfaction tools have been developed (constraint logic programming on booleans, finite domains, reals, and intervals) for that purpose <span class="citation">(e.g., Frühwirth 1998; Triska 2018)</span>. Some constraint handlers exist in R (see the CRAN task view for optimization problems), but more of them would be available via a bridge between R and Prolog.</p>
<p>Earlier approaches to connect Prolog and R have been published as SWI-Prolog packs <span class="citation">(real, rserve_client, Angelopoulos et al. 2013; Wielemaker 2021b)</span> and as a YAP module <span class="citation">(YapR, Azevedo 2011)</span>. Whereas real establishes a direct link to an embedded instance of R, <code>rserve-client</code> communicates with a local or remote R service <span class="citation">(Urbanek 2021)</span>. The former approach emphasizes speed, the latter might be preferred from a security perspective, especially in systems such as SWISH <span class="citation">(Wielemaker, Lager, and Riguzzi 2015)</span> that accept only a set of sandboxed commands for Prolog, but do not impose restrictions on R. A common feature of the two packages is that they provide an interface for R calls from Prolog, but not the other way round, that is, querying Prolog from R is not possible, so far.</p>
<p><code>rolog</code> fills this gap through Prolog queries in R scripts, for example, to perform efficient symbolic computations, searches in complex graphs, parsing natural language and definite clause grammars. In addition, two Prolog predicates are provided that enable Prolog to ring back to the R system for bidirectional communication. Similar to <code>real</code>, tight communication between the two systems is established by linking to a shared library that embeds the current version of SWI-Prolog. The exchange of data is facilitated by the C++ interfaces of the two languages <span class="citation">(Eddelbuettel and Balamuta 2018; Wielemaker 2021a)</span>. A less tight connection might be established using the recently developed machine query interface <span class="citation">(Zinda 2021)</span> that allows socket-based communication between foreign languages and SWI-Prolog (and, in fact, the <code>MQI</code> documentation includes an example in which R is called).</p>
<p>A bidirectional bridge between R and Prolog might overcome the limitations of both languages, thereby combining the extensive numerical and statistical power of the R system with Prolog’s skills in the representation of knowledge and reasoning. In addition to the useful little tools shown in the examples below, <code>rolog</code> can therefore contribute to progress at the intersection of traditional artificial intelligence and contemporary statistical programming.</p>
<p>The next section presents the interface of rolog in detail. Section 3 presents possible extensions of the package at both ends, in R and Prolog. Section 4 is a list of illustrative examples that offer useful extensions to the R system. Conclusions and further perspectives are summarized in Section 5.</p>
</div>
<div id="basic-syntax" class="section level1">
<h1>2. Basic syntax</h1>
<p><code>rolog</code> has a rather minimalistic syntax, providing only some basic ingredients to establish communication with an embedded SWI-Prolog. The ways to extend the interface are described in Section 3.</p>
<p>After installation (in R, with <code>install.packages(&quot;rolog&quot;)</code>), the package is loaded in the standard way using R’s <code>library()</code>-command.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">library</span>(rolog)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="co">#&gt; Welcome to SWI-Prolog (threaded, 64 bits, version 8.5.11-20-ge8c2e0dd0-DIRTY)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="co">#&gt; SWI-Prolog comes with ABSOLUTELY NO WARRANTY. This is free software.</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="co">#&gt; Please run ?- license. for legal details.</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span class="co">#&gt; </span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a><span class="co">#&gt; For online help and background, visit https://www.swi-prolog.org</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a><span class="co">#&gt; For built-in help, use ?- help(Topic). or ?- apropos(Word).</span></span></code></pre></div>
<p>We can see SWI-Prolog’s typical welcome message.</p>
<div id="r-interface" class="section level2">
<h2>R interface</h2>
<p>Most of the work can be done using the three R functions <code>query</code>, <code>submit</code>, and <code>clear</code>. The functions <code>consult</code>, <code>once</code>, and <code>findall</code> are provided for convenience. The R program in Listing 1 illustrates a query to Prolog’s <code>member/2</code> using <code>rolog</code>’s syntax rules.</p>
<p><code>consult</code>. In most applications, a number of Prolog facts and rules will be loaded into the system. To facilitate this recurrent task, the Prolog directive <code>consult/1</code> has been mirrored into R, <code>consult(filename)</code>, with <em>filename</em> given as a string (or a list of strings if multiple files are to be consulted). The function returns <code>TRUE</code> on success; in case of problems, it returns <code>FALSE</code> and an error message is shown.</p>
<p><code>query</code>. The function <code>query(call, options)</code> is used to create a Prolog query (without invoking it yet). The first argument <em>call</em> is a regular R call that is created using R’s function <code>call(name, ...)</code>. This call represents the Prolog predicate which will be queried in the later course. The creation of such predicates and Prolog terms is described below and can become quite contrived (see the examples in Section 4). The second argument, <em>options</em>, may be used for ad hoc modifications of the translation between R and Prolog, see the section below. The function returns <code>TRUE</code> on success. Note that the function does not check if the corresponding Prolog predicate actually exists (but see <code>submit()</code> below). Only a single query can be opened at a given time. If a new query <em>Q</em> is created while another query <em>R</em> is still open, a warning is shown and <em>R</em> is closed.</p>
<p><code>submit</code>. Once a query has been created, it can be submitted using <code>submit()</code>. If the query fails, the return value is <code>FALSE</code>. If the query succeeds, a list of constraints is returned, with bindings for the variables that satisfy the query. Repeated calls to submit are possible, returning the different solutions of a query (until it eventually fails). Programmatically distinguishing between the different types of return values for success and failure (list vs. <code>FALSE</code>) is facilitated by the R function <code>isFALSE(x)</code>.</p>
<p><code>clear</code>. Closes the query. The name of the function is chosen to avoid name clashes with R’s own built-in function <code>close</code>. The function returns an invisible <code>TRUE</code>, even if there is no open query.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="co"># member(1, [1, 2.0, a, &quot;b&quot;, X])</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="kw">query</span>(<span class="kw">call</span>(<span class="st">&quot;member&quot;</span>, 1L, <span class="kw">list</span>(1L, <span class="fl">2.0</span>, <span class="kw">quote</span>(a), <span class="st">&quot;b&quot;</span>, <span class="kw">expression</span>(X), <span class="ot">TRUE</span>)))</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span class="co">#&gt; attr(,&quot;query&quot;)</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a><span class="co">#&gt; [1] &quot;member(1, [1, 2.0, a, b, X, true])&quot;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a><span class="co"># returns an empty list, stating that member(1, [1 | _]) is satisfied</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a><span class="kw">submit</span>()</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a><span class="co">#&gt; list()</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a><span class="co"># returns a list, stating that the query is also satisfied if X = 1</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a><span class="kw">submit</span>()</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a><span class="co">#&gt; $X</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a><span class="co">#&gt; [1] 1</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true"></a><span class="co"># close the query</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true"></a><span class="kw">clear</span>()</span></code></pre></div>
<dl>
<dt>Listing 1.</dt>
<dd>A query to Prolog’s <code>member/2</code> predicate.
</dd>
</dl>
<p><code>once</code> and <code>findall</code>. The function <code>once(call, options)</code> is a convenience function that acts as a shortcut for <code>query(call, options)</code>, <code>submit()</code>, and <code>clear()</code>. Similarly, <code>findall(call, options)</code> abbreviates the commands <code>query(call, options)</code>, repetition of <code>submit()</code> until failure, and <code>clear()</code>, returning a list collecting the return value of the individual calls to submit.</p>
</div>
<div id="creating-prolog-terms-in-r" class="section level2">
<h2>Creating Prolog terms in R</h2>
<p>Table 1 summarizes the rules for the translation from R to Prolog. Most rules work in both directions, but a few exceptions exist. For example, there is an empty atom in Prolog, but no empty symbol in R, so the empty atom is translated to a character string in R.</p>
<dl>
<dt>Table 1</dt>
<dd>Creating Prolog terms from R
</dd>
</dl>
<table>
<thead>
<tr class="header">
<th align="left">R</th>
<th align="left">Prolog</th>
<th align="left">Note/Alternatives</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>expression(X)</code></td>
<td align="left">Variable X</td>
<td align="left">not necessarily uppercase</td>
</tr>
<tr class="even">
<td align="left"><code>as.symbol(abc)</code></td>
<td align="left">Atom abc</td>
<td align="left"><code>as.name</code>, <code>quote</code></td>
</tr>
<tr class="odd">
<td align="left"><code>TRUE</code>, <code>FALSE</code>, <code>NULL</code></td>
<td align="left">Atoms true, false, null</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><code>&quot;abc&quot;</code></td>
<td align="left">String &quot;abc&quot;</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"><code>3L</code></td>
<td align="left">Integer 3</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><code>3</code></td>
<td align="left">Float 3.0</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"><code>call(&quot;term&quot;, 1L, 2L)</code></td>
<td align="left">term(1, 2)</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><code>list(1L, 2L, 3L)</code></td>
<td align="left">List [1, 2, 3]</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"><code>list(a=1, b=2, c=3)</code></td>
<td align="left">List [a-1, b-2, c-3]</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><code>c(1, 2, 3)</code></td>
<td align="left">#(1.0, 2.0, 3.0)</td>
<td align="left">vectors of length &gt; 1</td>
</tr>
<tr class="odd">
<td align="left"><code>c(1L, 2L, 3L)</code> or <code>1:3</code></td>
<td align="left">&#39;%&#39;(1, 2, 3)</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><code>c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</code></td>
<td align="left">$$(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"><code>c(TRUE, FALSE, NA)</code></td>
<td align="left">!(true, false, na)</td>
<td align="left"></td>
</tr>
</tbody>
</table>
Moreover, R is mostly vectorized, lacking support for scalar entities (in R, scalar entities are treated as vectors of length 1. Conversely, Prolog does not natively support vectors or matrices. The problem is solved in the following way: %
<p>% In the reverse direction, Prolog terms like <code>#/N</code> are translated back to R vectors of length <span class="math inline">\(N\)</span>, including terms <code>#/0</code> and <code>#/1</code> that map to R vectors of length 0 and 1, respectively. To summarize, the rules for translation are not fully symmetrical. A quick check for symmetry of the representation is obtained by a query to <code>r_eval/2</code> (see also below, subsection Prolog interface):</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>Q &lt;-<span class="st"> </span><span class="kw">call</span>(<span class="st">&quot;r_eval&quot;</span>, <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="ot">NA</span>, <span class="ot">NaN</span>, <span class="ot">Inf</span>), <span class="kw">expression</span>(X))</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="kw">once</span>(Q, <span class="dt">options=</span><span class="kw">list</span>(<span class="dt">portray=</span><span class="ot">TRUE</span>))</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a><span class="co">#&gt; $X</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a><span class="co">#&gt; [1]   1   2  NA NaN Inf</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a><span class="co">#&gt; </span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a><span class="co">#&gt; attr(,&quot;query&quot;)</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a><span class="co">#&gt; [1] &quot;r_eval(#(1.0, 2.0, na, 1.5NaN, 1.0Inf), X)&quot;</span></span></code></pre></div>
</div>
<div id="package-options" class="section level2">
<h2>Package options</h2>
<p>A few package-specific options have been defined to allow some fine-tuning of the rules for translation between R and Prolog.</p>
<ul>
<li><em>realvec</em> (string): Name of the Prolog term for vectors of floats (default is <code>#</code>)</li>
<li><em>intvec</em> (string): same for vectors of integers (default is <code>%</code>)</li>
<li><em>boolvec</em> (string): same for vectors of logicals (default is <code>!</code>)</li>
<li><em>charvec</em> (string): same for vectors of character strings (default is <code>\$\$</code>). The single dollar cannot be used because it is the list operator in R.</li>
<li><em>scalar</em> (logical): if <code>TRUE</code> (default), R vectors of length 1 are translated to scalars in Prolog. If <code>FALSE</code>, R vectors are always translated to <code>#/N</code> etc., depending on the type.</li>
<li><em>portray</em> (logical): if <code>TRUE</code> (default in <code>query</code>), the result of <code>query</code>, <code>once</code> and <code>findall</code> includes an attribute with a representation of the query in Prolog.</li>
</ul>
<p>The command <code>rolog_options()</code> returns a list with all the options. The options can be globally modified with <code>options()</code> or in the optional argument of <code>query</code>, <code>once</code>, and <code>findall</code>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">options</span>(<span class="dt">rolog.intvec=</span><span class="st">&quot;%%&quot;</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>Q &lt;-<span class="st"> </span><span class="kw">call</span>(<span class="st">&quot;member&quot;</span>, <span class="kw">expression</span>(X), <span class="kw">list</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dv">4</span><span class="op">:</span><span class="dv">6</span>))</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span class="kw">once</span>(Q, <span class="dt">options=</span><span class="kw">list</span>(<span class="dt">intvec=</span><span class="st">&quot;%%&quot;</span>))</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a><span class="co">#&gt; $X</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a><span class="co">#&gt; [1] 1 2 3</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a><span class="co">#&gt; </span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a><span class="co">#&gt; attr(,&quot;query&quot;)</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a><span class="co">#&gt; [1] &quot;member(X, [%%(1, 2, 3), %%(4, 5, 6)])&quot;</span></span></code></pre></div>
</div>
<div id="prolog-interface" class="section level2">
<h2>Prolog interface</h2>
<p><code>rolog</code> offers some basic support to call R from Prolog, that is, connecting the two systems in the reverse direction. Two predicates can be used for this purpose, <code>r_eval(Call)</code> and <code>r_eval(Function, Result)</code>. The former just invokes R with the command <em>Call</em> (ignoring the result); the latter evaluates <em>Function</em> and unifies the result with <em>Result</em>. Note that proper quoting of R functions is needed at the Prolog end, especially with R functions that start with uppercase letters or contain a dot in their name (see Section 4).</p>
</div>
</div>
<div id="extending-the-package" class="section level1">
<h1>3. Extending the package</h1>
<p>The package is intentionally kept minimalistic, but can easily be extended by convenience functions on both ends, Prolog and R, to facilitate recurrent tasks and/or avoid cumbersome syntax. R is a functional language, whereas Prolog is declarative. Obviously, there cannot be a perfect one-to-one correspondence between the syntactic components of two programming languages that follow completely different paradigms. Whereas symbols, functions, numbers and character strings are easily mapped between R and Prolog, there are loose ends at both sides. In particular, Prolog variables are translated from and to R <em>expressions</em> (not to be confused with R symbols), and R vectors of length &gt; 1 are translated to the Prolog terms <code>#/N</code>, <code>%/N</code>, <code>!/N</code>, and <code>\$\$/N</code>, as mentioned above. These rules are, in principle, arbitrary and can be intercepted at several stages. The process is illustrated in Figure 1.</p>
<ul>
<li>R functions that may be used to pre-process specific R elements before translation to Prolog (see, e.g., the R function <code>as.rolog()</code>)</li>
<li>Prolog wrappers that manipulate the term before it is called and afterwards (see the example with dicts below)</li>
<li>R functions that post-process the result of a query</li>
</ul>
<p>The process is illustrated in Figure 1.</p>
<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.40.1 (20161225.0304)
 -->
<!-- Title: G Pages: 1 -->
<svg width="543pt" height="140pt" viewBox="0.00 0.00 543.44 140.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 136)">
<title>G</title>
<polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-136 539.4426,-136 539.4426,4 -4,4"></polygon>
<g id="clust1" class="cluster">
<title>cluster_0</title>
<polygon fill="#d3d3d3" stroke="#d3d3d3" points="113.7627,-72 113.7627,-124 431.1352,-124 431.1352,-72 113.7627,-72"></polygon>
</g>
<g id="clust2" class="cluster">
<title>cluster_1</title>
<polygon fill="#d3d3d3" stroke="#d3d3d3" points="111.0327,-8 111.0327,-60 433.8652,-60 433.8652,-8 111.0327,-8"></polygon>
</g>
<!-- Query -->
<g id="node1" class="node">
<title>Query</title>
<polygon fill="none" stroke="#000000" points="41.5163,-125 -.0164,-100 41.5163,-75 83.049,-100 41.5163,-125"></polygon>
<polyline fill="none" stroke="#000000" points="10.2648,-106.1886 10.2648,-93.8114 "></polyline>
<polyline fill="none" stroke="#000000" points="31.2352,-81.1886 51.7975,-81.1886 "></polyline>
<polyline fill="none" stroke="#000000" points="72.7679,-93.8114 72.7679,-106.1886 "></polyline>
<polyline fill="none" stroke="#000000" points="51.7975,-118.8114 31.2352,-118.8114 "></polyline>
<text text-anchor="middle" x="41.5163" y="-95.8" font-family="Times,serif" font-size="14.00" fill="#000000">Query</text>
</g>
<!-- r2rolog -->
<g id="node3" class="node">
<title>r2rolog</title>
<polygon fill="#ffffff" stroke="#ffffff" points="200.1212,-116 121.9757,-116 121.9757,-80 200.1212,-80 200.1212,-116"></polygon>
<text text-anchor="middle" x="161.0485" y="-93.8" font-family="Times,serif" font-size="14.00" fill="#000000">preproc(...)</text>
</g>
<!-- Query&#45;&gt;r2rolog -->
<g id="edge5" class="edge">
<title>Query-&gt;r2rolog</title>
<path fill="none" stroke="#000000" d="M81.9845,-99.3229C91.5353,-99.1631 101.8227,-98.991 111.7164,-98.8254"></path>
<polygon fill="#000000" stroke="#000000" points="111.8968,-102.323 121.8368,-98.6561 111.7796,-95.324 111.8968,-102.323"></polygon>
</g>
<!-- Result -->
<g id="node2" class="node">
<title>Result</title>
<polygon fill="none" stroke="#000000" points="67.2938,-56.7775 15.7389,-56.7775 15.7389,-5.2225 67.2938,-5.2225 67.2938,-56.7775"></polygon>
<polyline fill="none" stroke="#000000" points="27.7389,-56.7775 15.7389,-44.7775 "></polyline>
<polyline fill="none" stroke="#000000" points="15.7389,-17.2225 27.7389,-5.2225 "></polyline>
<polyline fill="none" stroke="#000000" points="55.2938,-5.2225 67.2938,-17.2225 "></polyline>
<polyline fill="none" stroke="#000000" points="67.2938,-44.7775 55.2938,-56.7775 "></polyline>
<text text-anchor="middle" x="41.5163" y="-26.8" font-family="Times,serif" font-size="14.00" fill="#000000">Result</text>
</g>
<!-- rolog2r -->
<g id="node6" class="node">
<title>rolog2r</title>
<polygon fill="#ffffff" stroke="#ffffff" points="203.0801,-52 119.0169,-52 119.0169,-16 203.0801,-16 203.0801,-52"></polygon>
<text text-anchor="middle" x="161.0485" y="-29.8" font-family="Times,serif" font-size="14.00" fill="#000000">postproc(...)</text>
</g>
<!-- Result&#45;&gt;rolog2r -->
<g id="edge8" class="edge">
<title>Result-&gt;rolog2r</title>
<path fill="none" stroke="#000000" d="M77.8161,-31.911C90.7172,-32.2348 105.3525,-32.6022 118.714,-32.9375"></path>
<polygon fill="#000000" stroke="#000000" points="77.5377,-28.4031 67.453,-31.651 77.362,-35.4008 77.5377,-28.4031"></polygon>
</g>
<!-- forth -->
<g id="node4" class="node">
<title>forth</title>
<ellipse fill="#ffffff" stroke="#ffffff" cx="276.9143" cy="-98" rx="37.7006" ry="18"></ellipse>
<text text-anchor="middle" x="276.9143" y="-93.8" font-family="Times,serif" font-size="14.00" fill="#000000">(rolog)</text>
</g>
<!-- r2rolog&#45;&gt;forth -->
<g id="edge1" class="edge">
<title>r2rolog-&gt;forth</title>
<path fill="none" stroke="#000000" d="M200.2754,-98C209.4358,-98 219.2952,-98 228.7923,-98"></path>
<polygon fill="#000000" stroke="#000000" points="228.9053,-101.5001 238.9053,-98 228.9053,-94.5001 228.9053,-101.5001"></polygon>
</g>
<!-- rolog_pl -->
<g id="node5" class="node">
<title>rolog_pl</title>
<polygon fill="#ffffff" stroke="#ffffff" points="422.9567,-116 353.6728,-116 353.6728,-80 422.9567,-80 422.9567,-116"></polygon>
<text text-anchor="middle" x="388.3147" y="-93.8" font-family="Times,serif" font-size="14.00" fill="#000000">preproc/2</text>
</g>
<!-- forth&#45;&gt;rolog_pl -->
<g id="edge2" class="edge">
<title>forth-&gt;rolog_pl</title>
<path fill="none" stroke="#000000" d="M314.9404,-98C324.1055,-98 333.9828,-98 343.4286,-98"></path>
<polygon fill="#000000" stroke="#000000" points="343.4549,-101.5001 353.4549,-98 343.4548,-94.5001 343.4549,-101.5001"></polygon>
</g>
<!-- Prolog -->
<g id="node9" class="node">
<title>Prolog</title>
<ellipse fill="none" stroke="#000000" cx="498.6539" cy="-66" rx="36.5786" ry="36.5786"></ellipse>
<polyline fill="none" stroke="#000000" points="522.986,-93.5915 474.3219,-93.5915 "></polyline>
<polyline fill="none" stroke="#000000" points="522.986,-38.4085 474.3219,-38.4085 "></polyline>
<text text-anchor="middle" x="498.6539" y="-61.8" font-family="Times,serif" font-size="14.00" fill="#000000">Prolog</text>
</g>
<!-- rolog_pl&#45;&gt;Prolog -->
<g id="edge6" class="edge">
<title>rolog_pl:e-&gt;Prolog</title>
<path fill="none" stroke="#000000" d="M423.3147,-98C435.0752,-98 447.1053,-94.6558 458.0017,-90.1297"></path>
<polygon fill="#000000" stroke="#000000" points="459.6104,-93.2427 467.2502,-85.9022 456.7003,-86.8763 459.6104,-93.2427"></polygon>
</g>
<!-- back -->
<g id="node7" class="node">
<title>back</title>
<ellipse fill="#ffffff" stroke="#ffffff" cx="276.9143" cy="-34" rx="37.7006" ry="18"></ellipse>
<text text-anchor="middle" x="276.9143" y="-29.8" font-family="Times,serif" font-size="14.00" fill="#000000">(rolog)</text>
</g>
<!-- rolog2r&#45;&gt;back -->
<g id="edge3" class="edge">
<title>rolog2r-&gt;back</title>
<path fill="none" stroke="#000000" d="M213.4869,-34C222.0216,-34 230.7168,-34 238.8225,-34"></path>
<polygon fill="#000000" stroke="#000000" points="213.2065,-30.5001 203.2065,-34 213.2064,-37.5001 213.2065,-30.5001"></polygon>
</g>
<!-- pl_rolog -->
<g id="node8" class="node">
<title>pl_rolog</title>
<polygon fill="#ffffff" stroke="#ffffff" points="425.9158,-52 350.7137,-52 350.7137,-16 425.9158,-16 425.9158,-52"></polygon>
<text text-anchor="middle" x="388.3147" y="-29.8" font-family="Times,serif" font-size="14.00" fill="#000000">postproc/2</text>
</g>
<!-- back&#45;&gt;pl_rolog -->
<g id="edge4" class="edge">
<title>back-&gt;pl_rolog</title>
<path fill="none" stroke="#000000" d="M325.114,-34C333.595,-34 342.3123,-34 350.46,-34"></path>
<polygon fill="#000000" stroke="#000000" points="324.9405,-30.5001 314.9404,-34 324.9404,-37.5001 324.9405,-30.5001"></polygon>
</g>
<!-- pl_rolog&#45;&gt;Prolog -->
<g id="edge7" class="edge">
<title>pl_rolog:e-&gt;Prolog</title>
<path fill="none" stroke="#000000" d="M436.4748,-34.8303C447.5233,-36.5766 458.4,-40.8717 467.8907,-45.7339"></path>
<polygon fill="#000000" stroke="#000000" points="436.5666,-31.3262 426.3147,-34 435.9964,-38.303 436.5666,-31.3262"></polygon>
</g>
</g>
</svg>

<dl>
<dt>Figure 1</dt>
<dd>Workflow in rolog
</dd>
</dl>
<div id="pre-processing-in-r" class="section level2">
<h2>Pre-processing in R</h2>
<p>We have seen above that raising even simple everyday Prolog queries such as <code>member(X, [1, 2, 3, a, b])</code> require complicated R expressions such as <code>call(&quot;member&quot;, expression(X), list(1, 2, 3, quote(a), quote(b)))</code>. The R function <code>as.rolog(Call)</code> is meant to simplify this a bit by translating symbols starting with a dot to Prolog variables, and calls like <code>&quot;&quot;[1, 2, 3, a, b]</code> to lists. The argument <em>Call</em> is typically a quoted R call or symbol:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>Q &lt;-<span class="st"> </span><span class="kw">quote</span>(<span class="kw">member</span>(.X, <span class="st">&quot;&quot;</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, a, b]))</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="kw">as.rolog</span>(Q)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a><span class="co">#&gt; member(expression(X), list(1, 2, 3, a, b))</span></span></code></pre></div>
<p>Note that the name of the variable will still be <em>X</em> in the later course, not “dot-X”. A bit flexibility is lost because <code>quote()</code> treats the arguments <em>a</em>, <em>b</em> as symbols; to evaluate the respective variables (i.e., “unquote”), they can be put in parentheses:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>a &lt;-<span class="st"> </span><span class="dv">4</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>Q &lt;-<span class="st"> </span><span class="kw">quote</span>(<span class="kw">member</span>(.X, <span class="st">&quot;&quot;</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, a, (a)]))</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span class="kw">as.rolog</span>(Q)</span></code></pre></div>
<p>Section 3 includes an example for mathematical rendering of R expressions. In that example, a pre-processing function is used to bring function calls with named arguments to a canonical form which is then handled in Prolog. More sophisticated work with quasi-quotations and unquoting expressions is described in “Advanced R” <span class="citation">(Wickham 2019)</span>.</p>
</div>
<div id="post-processing-in-r" class="section level2">
<h2>Post-processing in R</h2>
<p>This may again be a function that reverts some of the manipulations during pre-processing. For <code>once()</code> and <code>submit()</code>, such a function would operate on the bindings. For example, many Prolog programmers are used to operate with atoms instead of character strings, whereas character strings are the preferred representation of symbolic information in R. The following function converts the result of a query like <code>member(X, [a, b, c])</code> to strings.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>stringify &lt;-<span class="st"> </span><span class="cf">function</span>(x)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>{</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>  <span class="cf">if</span>(<span class="kw">is.name</span>(x))</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>    <span class="kw">return</span>(<span class="kw">as.character</span>(x))</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>  <span class="cf">if</span>(<span class="kw">is.call</span>(x))</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a>    x[<span class="op">-</span><span class="dv">1</span>] &lt;-<span class="st"> </span><span class="kw">lapply</span>(x[<span class="op">-</span><span class="dv">1</span>], <span class="dt">FUN=</span>stringify)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>  <span class="cf">if</span>(<span class="kw">is.list</span>(x))</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a>    x &lt;-<span class="st"> </span><span class="kw">lapply</span>(x, <span class="dt">FUN=</span>stringify)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a>  <span class="kw">return</span>(x)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true"></a>}</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true"></a></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true"></a>Q &lt;-<span class="st"> </span><span class="kw">quote</span>(<span class="kw">member</span>(.X, <span class="st">&quot;&quot;</span>[a, b, c]))</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true"></a>R &lt;-<span class="st"> </span><span class="kw">findall</span>(<span class="kw">as.rolog</span>(Q))</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true"></a>S &lt;-<span class="st"> </span><span class="kw">stringify</span>(R)</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true"></a><span class="kw">unlist</span>(S)   <span class="co"># the unlist saves space in the output</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true"></a><span class="co">#&gt;   X   X   X </span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true"></a><span class="co">#&gt; &quot;a&quot; &quot;b&quot; &quot;c&quot;</span></span></code></pre></div>
</div>
<div id="pre--and-post-processing-in-prolog" class="section level2">
<h2>Pre- and post-processing in Prolog</h2>
<p>Recent versions of SWI-Prolog support so-called dictionaries of the form <code>Tag{Key1:Value1, Key2:Value2, ...}</code>. The tag is typically an atom (but can be a variable, as well), the keys are unique atom or integers; the values can be anything. Suppose we have a Prolog predicate that does something with dicts, and we would like to query it from R. The simplest solution is a wrapper in Prolog that translates <em>key</em>-<em>value</em> pairs <code>[Key1-Value1, Key2-Value2, ...]</code> back and forth to dicts:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>do_something_with_pairs(<span class="dt">Pairs0</span><span class="kw">,</span> <span class="dt">Pairs1</span>) <span class="kw">:-</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>    dict_pairs(<span class="dt">Dict0</span><span class="kw">,</span> my_dict<span class="kw">,</span> <span class="dt">Pairs0</span>)<span class="kw">,</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>    do_something_with_dicts(<span class="dt">Dict0</span><span class="kw">,</span> <span class="dt">Dict1</span>)<span class="kw">,</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>    dict_pairs(<span class="dt">Dict1</span><span class="kw">,</span> my_dict<span class="kw">,</span> <span class="dt">Pairs1</span>)<span class="kw">.</span></span></code></pre></div>
<p><code>do_something_with_pairs/2</code> can then be queried from R using, for example, lists with named elements (see Table 1).</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">once</span>(<span class="kw">call</span>(<span class="st">&quot;do_something_with_pairs&quot;</span>, <span class="kw">list</span>(<span class="dt">a=</span><span class="dv">1</span>, <span class="dt">b=</span><span class="dv">2</span>), <span class="kw">expression</span>(X)))</span></code></pre></div>
<p>In the code above, <code>dict_pairs/2</code> takes the role of both <code>preproc/2</code> and <code>postproc/2</code> in Figure 1. It illustrates that complicated syntax on the R side can be much simplified when doing the conversion at the Prolog end. Ways to extend Prolog by add-ons (“packs”) are shown in the next section.</p>
</div>
</div>
<div id="examples-and-use-cases" class="section level1">
<h1>4. Examples and use cases</h1>
<p>In this section we present a few usage examples for the <code>rolog</code> package in increasing complexity. Although the code snippets are mostly self-explanatory, some familiarity with the Prolog language is helpful.</p>
<div id="hello-world" class="section level2">
<h2>Hello, world</h2>
<p>Prolog’s typical <em>hello world</em> example is a search through a directed acyclic graph (DAG), for example, a family tree like the one given in Listing 2.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>parent(pam<span class="kw">,</span> bob)<span class="kw">.</span> parent(bob<span class="kw">,</span> ann)<span class="kw">.</span> parent(bob<span class="kw">,</span> pat)<span class="kw">.</span> parent(pat<span class="kw">,</span> jim)<span class="kw">.</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>ancestor(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Z</span>) <span class="kw">:-</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>    parent(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Z</span>)<span class="kw">.</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>ancestor(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Z</span>) <span class="kw">:-</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a>    parent(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>)<span class="kw">,</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a>    ancestor(<span class="dt">Y</span><span class="kw">,</span> <span class="dt">Z</span>)<span class="kw">.</span></span></code></pre></div>
<dl>
<dt>Listing 2</dt>
<dd>A family tree in Prolog (see also family.pl)
</dd>
</dl>
<p>Listing 2 is included in the package and is accessed using the function <code>system.file(...)</code>. Within Prolog, the normal workflow is to consult the code with <code>[family]</code> and then to raise queries such as <code>ancestor(X, jim)</code>, which returns, one by one, four solutions for the variable <em>X</em>. In R, we obtain the following results:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="kw">library</span>(rolog)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a><span class="kw">consult</span>(<span class="kw">system.file</span>(<span class="kw">file.path</span>(<span class="st">&quot;pl&quot;</span>, <span class="st">&quot;family.pl&quot;</span>), <span class="dt">package=</span><span class="st">&quot;rolog&quot;</span>))</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a><span class="kw">query</span>(<span class="kw">call</span>(<span class="st">&quot;ancestor&quot;</span>, <span class="kw">expression</span>(X), <span class="kw">quote</span>(jim)))</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a><span class="co">#&gt; attr(,&quot;query&quot;)</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a><span class="co">#&gt; [1] &quot;ancestor(X, jim)&quot;</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a><span class="kw">submit</span>()        <span class="co"># solutions for X</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a><span class="co">#&gt; $X</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a><span class="co">#&gt; pat</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true"></a><span class="kw">submit</span>()        <span class="co"># etc.</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true"></a><span class="co">#&gt; $X</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true"></a><span class="co">#&gt; pam</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true"></a><span class="kw">clear</span>()         <span class="co"># close the query</span></span></code></pre></div>
<p>As stated above, <code>consult()</code> loads the facts and rules of Listing 2 into the Prolog database. <code>query(Expr)</code> initializes the query <em>Expr</em>, and the subsequent calls to <code>submit</code> return the conditions under which the query succeeds. In this example, the query succeeds if <em>X</em> is either <em>pat</em>, <em>pam</em>, or <em>bob</em>. A query is closed with <code>clear()</code>, or automatically if the query fails. If we are interested in just the first solution, we can use <code>once(expr)</code> as a shortcut to <code>query(Expr)</code>, then <code>submit()</code>, then <code>clear()</code>. If we want to collect all solutions of a query with a finite set of solutions, we can use <code>findall(Expr)</code>.</p>
<p>As mentioned in Section 2, a simplified syntax is provided by <code>as.rolog(...)</code> that accepts quoted expressions with dots indicating Prolog variables:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a>Q &lt;-<span class="st"> </span><span class="kw">quote</span>(<span class="kw">ancestor</span>(.X, jim))</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a><span class="kw">findall</span>(<span class="kw">as.rolog</span>(Q))</span></code></pre></div>
</div>
<div id="backdoor-test" class="section level2">
<h2>Backdoor test</h2>
<p>A useful application of DAGs is confounder adjustment in causal analysis <span class="citation">(Greenland, Pearl, and Robins 1999; Barrett 2021)</span>. The Prolog file <code>backdoor.pl</code> is an implementation of Greenland et al.’s criteria for the backdoor test for <em>d</em>-separation in DAGs, with a predicate <code>minimal/3</code> that searches for minimally sufficient sets of variables for confounder adjustment on the causal path between exposure and outcome. The nodes and arrows refer to Figure 12 in Greenland et al.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="kw">consult</span>(<span class="kw">system.file</span>(<span class="kw">file.path</span>(<span class="st">&quot;pl&quot;</span>, <span class="st">&quot;backdoor.pl&quot;</span>), <span class="dt">package=</span><span class="st">&quot;rolog&quot;</span>))</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>node &lt;-<span class="st"> </span><span class="cf">function</span>(N) <span class="kw">invisible</span>(<span class="kw">once</span>(<span class="kw">call</span>(<span class="st">&quot;assert&quot;</span>, <span class="kw">call</span>(<span class="st">&quot;node&quot;</span>, N))))</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a><span class="kw">node</span>(<span class="st">&quot;a&quot;</span>); <span class="kw">node</span>(<span class="st">&quot;b&quot;</span>); <span class="kw">node</span>(<span class="st">&quot;c&quot;</span>); <span class="kw">node</span>(<span class="st">&quot;f&quot;</span>); <span class="kw">node</span>(<span class="st">&quot;u&quot;</span>)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a><span class="kw">node</span>(<span class="st">&quot;e&quot;</span>) <span class="co"># exposure</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a><span class="kw">node</span>(<span class="st">&quot;d&quot;</span>) <span class="co"># outcome</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a>arrow &lt;-<span class="st"> </span><span class="cf">function</span>(X, Y) <span class="kw">invisible</span>(<span class="kw">once</span>(<span class="kw">call</span>(<span class="st">&quot;assert&quot;</span>, <span class="kw">call</span>(<span class="st">&quot;arrow&quot;</span>, X, Y))))</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a><span class="kw">arrow</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;d&quot;</span>); <span class="kw">arrow</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;f&quot;</span>); <span class="kw">arrow</span>(<span class="st">&quot;b&quot;</span>, <span class="st">&quot;d&quot;</span>); <span class="kw">arrow</span>(<span class="st">&quot;b&quot;</span>, <span class="st">&quot;f&quot;</span>)</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a><span class="kw">arrow</span>(<span class="st">&quot;c&quot;</span>, <span class="st">&quot;d&quot;</span>); <span class="kw">arrow</span>(<span class="st">&quot;c&quot;</span>, <span class="st">&quot;f&quot;</span>); <span class="kw">arrow</span>(<span class="st">&quot;e&quot;</span>, <span class="st">&quot;d&quot;</span>); <span class="kw">arrow</span>(<span class="st">&quot;f&quot;</span>, <span class="st">&quot;e&quot;</span>)</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a><span class="kw">arrow</span>(<span class="st">&quot;u&quot;</span>, <span class="st">&quot;a&quot;</span>); <span class="kw">arrow</span>(<span class="st">&quot;u&quot;</span>, <span class="st">&quot;b&quot;</span>); <span class="kw">arrow</span>(<span class="st">&quot;u&quot;</span>, <span class="st">&quot;c&quot;</span>)</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true"></a></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true"></a>R &lt;-<span class="st"> </span><span class="kw">findall</span>(<span class="kw">call</span>(<span class="st">&quot;minimal&quot;</span>, <span class="st">&quot;e&quot;</span>, <span class="st">&quot;d&quot;</span>, <span class="kw">expression</span>(S)))</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true"></a><span class="kw">unlist</span>(R)</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true"></a><span class="co">#&gt;  S1  S2  S3   S </span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true"></a><span class="co">#&gt; &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;f&quot;</span></span></code></pre></div>
<p>The query to <code>minimal/3</code> returns two minimally sufficient sets of covariates for confounder adjustment (namely, {a, b, c} and {f}).</p>
</div>
<div id="definite-clause-grammars" class="section level2">
<h2>Definite clause grammars</h2>
<p>One of the main driving forces of Prolog development was natural language processing <span class="citation">(Dahl 1981)</span>. Therefore, the next example is an illustration of sentence parsing using so-called definite clause grammars. As Listing 3 shows, rolog can access modules from SWI’s standard library (e.g., “dcg/basics.pl”).</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="kw">:-</span> use_module(library(dcg<span class="fu">/</span>basics))<span class="kw">.</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>s(s(<span class="dt">NP</span><span class="kw">,</span> <span class="dt">VP</span>)) <span class="kw">--&gt;</span> np(<span class="dt">NP</span><span class="kw">,</span> <span class="dt">C</span>)<span class="kw">,</span> blank<span class="kw">,</span> vp(<span class="dt">VP</span><span class="kw">,</span> <span class="dt">C</span>)<span class="kw">.</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>np(<span class="dt">NP</span><span class="kw">,</span> <span class="dt">C</span>) <span class="kw">--&gt;</span> pn(<span class="dt">NP</span><span class="kw">,</span> <span class="dt">C</span>)<span class="kw">.</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>np(np(<span class="dt">Det</span><span class="kw">,</span> <span class="dt">N</span>)<span class="kw">,</span> <span class="dt">C</span>) <span class="kw">--&gt;</span> det(<span class="dt">Det</span><span class="kw">,</span> <span class="dt">C</span>)<span class="kw">,</span> blank<span class="kw">,</span> n(<span class="dt">N</span><span class="kw">,</span> <span class="dt">C</span>)<span class="kw">.</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>np(np(<span class="dt">Det</span><span class="kw">,</span> <span class="dt">N</span><span class="kw">,</span> <span class="dt">PP</span>)<span class="kw">,</span> <span class="dt">C</span>) <span class="kw">--&gt;</span> det(<span class="dt">Det</span><span class="kw">,</span> <span class="dt">C</span>)<span class="kw">,</span> blank<span class="kw">,</span> n(<span class="dt">N</span><span class="kw">,</span> <span class="dt">C</span>)<span class="kw">,</span> blank<span class="kw">,</span> pp(<span class="dt">PP</span>)<span class="kw">.</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a>vp(vp(<span class="dt">V</span><span class="kw">,</span> <span class="dt">NP</span>)<span class="kw">,</span> <span class="dt">C</span>) <span class="kw">--&gt;</span> v(<span class="dt">V</span><span class="kw">,</span> <span class="dt">C</span>)<span class="kw">,</span> blank<span class="kw">,</span> np(<span class="dt">NP</span><span class="kw">,</span> <span class="dt">_</span>)<span class="kw">.</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a>vp(vp(<span class="dt">V</span><span class="kw">,</span> <span class="dt">NP</span><span class="kw">,</span> <span class="dt">PP</span>)<span class="kw">,</span> <span class="dt">C</span>) <span class="kw">--&gt;</span> v(<span class="dt">V</span><span class="kw">,</span> <span class="dt">C</span>)<span class="kw">,</span> blank<span class="kw">,</span> np(<span class="dt">NP</span><span class="kw">,</span> <span class="dt">_</span>)<span class="kw">,</span> blank<span class="kw">,</span> pp(<span class="dt">PP</span>)<span class="kw">.</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a>pp(pp(<span class="dt">P</span><span class="kw">,</span> <span class="dt">NP</span>)) <span class="kw">--&gt;</span> p(<span class="dt">P</span>)<span class="kw">,</span> blank<span class="kw">,</span> np(<span class="dt">NP</span><span class="kw">,</span> <span class="dt">_</span>)<span class="kw">.</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true"></a>det(det(a)<span class="kw">,</span> sg) <span class="kw">--&gt;</span> <span class="st">`</span><span class="er">a</span><span class="st">`</span><span class="kw">.</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true"></a>det(det(the)<span class="kw">,</span> <span class="dt">_</span>) <span class="kw">--&gt;</span> <span class="st">`</span><span class="er">the</span><span class="st">`</span><span class="kw">.</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true"></a>pn(pn(john)<span class="kw">,</span> sg) <span class="kw">--&gt;</span> <span class="st">`</span><span class="er">john</span><span class="st">`</span><span class="kw">.</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true"></a>n(n(man)<span class="kw">,</span> sg) <span class="kw">--&gt;</span> <span class="st">`</span><span class="er">man</span><span class="st">`</span><span class="kw">.</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true"></a>n(n(men)<span class="kw">,</span> pl) <span class="kw">--&gt;</span> <span class="st">`</span><span class="er">men</span><span class="st">`</span><span class="kw">.</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true"></a>n(n(telescope)<span class="kw">,</span> sg) <span class="kw">--&gt;</span> <span class="st">`</span><span class="er">telescope</span><span class="st">`</span><span class="kw">.</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true"></a>v(v(sees)<span class="kw">,</span> sg) <span class="kw">--&gt;</span> <span class="st">`</span><span class="er">sees</span><span class="st">`</span><span class="kw">.</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true"></a>v(v(see)<span class="kw">,</span> pl) <span class="kw">--&gt;</span> <span class="st">`</span><span class="er">see</span><span class="st">`</span><span class="kw">.</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true"></a>p(p(with)) <span class="kw">--&gt;</span> <span class="st">`</span><span class="er">with</span><span class="st">`</span><span class="kw">.</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true"></a></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true"></a><span class="co">% Translate R string to code points and invoke phrase/2</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true"></a>sentence(<span class="dt">Tree</span><span class="kw">,</span> <span class="dt">Sentence</span>) <span class="kw">:-</span></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true"></a>    string_codes(<span class="dt">Sentence</span><span class="kw">,</span> <span class="dt">Codes</span>)<span class="kw">,</span></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true"></a>    <span class="kw">phrase</span>(s(<span class="dt">Tree</span>)<span class="kw">,</span> <span class="dt">Codes</span>)<span class="kw">.</span></span></code></pre></div>
<dl>
<dt>Listing 3</dt>
<dd>Simple grammar and lexicon. <code>sentence/2</code> pre-processes the R call.
</dd>
</dl>
<p>As in the first example, we first consult a little Prolog program with a minimalistic grammar and lexicon (Listing 3, see also <code>pl/telescope.pl</code>), and then raise a query asking for the syntactic structure of “john sees a man with a telescope”. Closer inspection of the two results reveals the two possible meanings, “john sees a man <em>who carries</em> a telescope” versus “john sees a man <em>through</em> a telescope”. Further Prolog examples of natural language processing are found in , including the resolution of anaphoric references and the extraction of semantic meaning.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="kw">consult</span>(<span class="kw">system.file</span>(<span class="kw">file.path</span>(<span class="st">&quot;pl&quot;</span>, <span class="st">&quot;telescope.pl&quot;</span>), <span class="dt">package=</span><span class="st">&quot;rolog&quot;</span>))</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>Q &lt;-<span class="st"> </span><span class="kw">quote</span>(<span class="kw">sentence</span>(.Tree, <span class="st">&quot;john sees a man with a telescope&quot;</span>))</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a><span class="kw">unlist</span>(<span class="kw">findall</span>(<span class="kw">as.rolog</span>(Q)))</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a><span class="co">#&gt; $Tree</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a><span class="co">#&gt; s(pn(john), vp(v(sees), np(det(a), n(man), pp(p(with), np(det(a), </span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a><span class="co">#&gt;     n(telescope))))))</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true"></a><span class="co">#&gt; </span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true"></a><span class="co">#&gt; $Tree</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true"></a><span class="co">#&gt; s(pn(john), vp(v(sees), np(det(a), n(man)), pp(p(with), np(det(a), </span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true"></a><span class="co">#&gt;     n(telescope)))))</span></span></code></pre></div>
</div>
<div id="installation-of-add-ons-for-prolog" class="section level2">
<h2>Installation of add-ons for Prolog</h2>
<p>In description of the previous example, we noted in passing that <code>rolog</code> can access the built-in libraries of SWI-Prolog (e.g., by calls to <code>use_module/1,2</code>). It is also possible to extend the installation by add-ons, including add-ons that require compilation, if the build tools (essentially, RTools under Windows, and xcode under macOS) are properly configured. This is illustrated below by the demo add-on <code>environ</code> <span class="citation">(Wielemaker 2012)</span> that collects the current environment variables.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="kw">once</span>(<span class="kw">call</span>(<span class="st">&quot;pack_install&quot;</span>, </span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>          <span class="kw">quote</span>(environ), <span class="kw">list</span>(<span class="kw">call</span>(<span class="st">&quot;interactive&quot;</span>, <span class="ot">FALSE</span>))))</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a><span class="kw">once</span>(<span class="kw">call</span>(<span class="st">&quot;use_module&quot;</span>, <span class="kw">call</span>(<span class="st">&quot;library&quot;</span>, <span class="kw">quote</span>(environ))))</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a><span class="kw">once</span>(<span class="kw">call</span>(<span class="st">&quot;environ&quot;</span>, <span class="kw">expression</span>(X)))</span></code></pre></div>
<p>The query then unifies <em>X</em> with a list with <code>Key=Value</code> terms. The purpose if this example is obviously not to mimic the built-in function <code>Sys.getenv()</code> from R, but to illustrate the installation and usage of Prolog extensions from within R. In most situations, the user would install the pack from within Prolog with <code>pack_install(environ)</code>.</p>
</div>
<div id="term-manipulation" class="section level2">
<h2>Term manipulation</h2>
<p>Prolog is homoiconic, that is, code is data. In this example, we make use of Prolog’s ability to match expressions against given patterns and modify these expressions according to a few predefined “buggy rules” <span class="citation">(Brown and Burton 1978)</span>, inspired by recurrent mistakes in the statistics exams of our students. Consider the <span class="math inline">\(t\)</span>-statistic for comparing an observed group average to a population mean:</p>
<p><span class="math display">\[
T = \frac{\overline{X} - \mu}{s / \sqrt{N}}
\]</span></p>
<p>Some mistakes may occur in this calculation, for example, omission of the implicit parentheses around the numerator and the denominator when typing the numbers into a calculator, resulting in <span class="math inline">\(\overline{X} - \frac{\mu}{s} \div \sqrt{N}\)</span>, or forgetting the square root around <span class="math inline">\(N\)</span>, or both. Prolog code for the two buggy rules is given in Listing 4.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="co">% Correct steps and mistakes</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>expert(tratio(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Mu</span><span class="kw">,</span> <span class="dt">S</span><span class="kw">,</span> <span class="dt">N</span>)<span class="kw">,</span> frac(<span class="dt">X</span> <span class="fu">-</span> <span class="dt">Mu</span><span class="kw">,</span> <span class="dt">S</span> <span class="fu">/</span> sqrt(<span class="dt">N</span>)))<span class="kw">.</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>buggy(frac(<span class="dt">X</span> <span class="fu">-</span> <span class="dt">Mu</span><span class="kw">,</span> <span class="dt">S</span> <span class="fu">/</span> <span class="dt">SQRTN</span>)<span class="kw">,</span> <span class="dt">X</span> <span class="fu">-</span> frac(<span class="dt">Mu</span><span class="kw">,</span> <span class="dt">S</span>) <span class="fu">/</span> <span class="dt">SQRTN</span>)<span class="kw">.</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>buggy(sqrt(<span class="dt">N</span>)<span class="kw">,</span> <span class="dt">N</span>)<span class="kw">.</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a><span class="co">% Apply expert and buggy rules, or enter expressions</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a>step(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>) <span class="kw">:-</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true"></a>    expert(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>) <span class="kw">;</span> buggy(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>)<span class="kw">.</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true"></a>step(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>) <span class="kw">:-</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true"></a>    <span class="dt">compound</span>(<span class="dt">X</span>)<span class="kw">,</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true"></a>    mapargs(search<span class="kw">,</span> <span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>)<span class="kw">,</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true"></a>    dif(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>)<span class="kw">.</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true"></a></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true"></a><span class="co">% Search through problem space</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true"></a>search(<span class="dt">X</span><span class="kw">,</span> <span class="dt">X</span>)<span class="kw">.</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true"></a>search(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Z</span>) <span class="kw">:-</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true"></a>    step(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Y</span>)<span class="kw">,</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true"></a>    search(<span class="dt">Y</span><span class="kw">,</span> <span class="dt">Z</span>)<span class="kw">.</span></span></code></pre></div>
<dl>
<dt>Listing 4</dt>
<dd>Manipulating terms in Prolog
</dd>
</dl>
<p>The little e-learning system shown in Listing 4 produces six response alternatives. The fourth and the sixth result are combinations of the two buggy rules (parenthesis, then square root, and the other way round). Some additional filters would be needed to eliminate trivial and redundant solutions .</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="kw">consult</span>(<span class="kw">system.file</span>(<span class="kw">file.path</span>(<span class="st">&quot;pl&quot;</span>, <span class="st">&quot;buggy.pl&quot;</span>), <span class="dt">package=</span><span class="st">&quot;rolog&quot;</span>))</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a>Q &lt;-<span class="st"> </span><span class="kw">quote</span>(<span class="kw">search</span>(<span class="kw">tratio</span>(x, mu, s, n), .S))</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a><span class="kw">unlist</span>(<span class="kw">findall</span>(<span class="kw">as.rolog</span>(Q)))</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a><span class="co">#&gt; $S</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a><span class="co">#&gt; tratio(x, mu, s, n)</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a><span class="co">#&gt; </span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a><span class="co">#&gt; $S</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true"></a><span class="co">#&gt; frac(x - mu, s/sqrt(n))</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true"></a><span class="co">#&gt; </span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true"></a><span class="co">#&gt; $S</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true"></a><span class="co">#&gt; x - frac(mu, s)/sqrt(n)</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true"></a><span class="co">#&gt; </span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true"></a><span class="co">#&gt; $S</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true"></a><span class="co">#&gt; x - frac(mu, s)/n</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true"></a><span class="co">#&gt; </span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true"></a><span class="co">#&gt; $S</span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true"></a><span class="co">#&gt; frac(x - mu, s/n)</span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true"></a><span class="co">#&gt; </span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true"></a><span class="co">#&gt; $S</span></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true"></a><span class="co">#&gt; x - frac(mu, s)/n</span></span></code></pre></div>
<p>An important feature of such a term manipulation is that the evaluation of the term can be postponed; for example, there is no need to instantiate the variables <em>x</em>, <em>mu</em>, <em>s</em>, and <em>n</em> with given values before raising a query. This is especially helpful for variables that may represent larger sets of data in later steps.</p>
<p>It should be mentioned that R is homoiconic, too, and the Prolog code above can, in principle, be rewritten in R using non-standard evaluation techniques <span class="citation">(Wickham 2019)</span>. Prolog’s inbuilt pattern matching algorithm simplifies things a lot, though.</p>
</div>
<div id="rendering-mathematical-expressions" class="section level2">
<h2>Rendering mathematical expressions</h2>
<p>The R extension of the markdown language <span class="citation">(Xie, Dervieux, and Riederer 2020)</span> enables reproducible statistical reports with nice typesetting in HTML, Microsoft Word, and Latex. However, so far, R expressions such as <code>pbinom(k, N, p)</code> are typeset as-is; prettier mathematical expressions such as <span class="math inline">\(P_\mathrm{Bi}(X \le k; N, p)\)</span> require Latex commands like <code>P_\mathrm{Bi}\left(X \le k; N, p\right)</code>, which are cumbersome to type in and hard to read even if the expressions are simple. Since recently, manual pages include support for mathematical expressions <span class="citation">(Sarkar and Hornik 2022)</span>, which already is a big improvement.</p>
<p>Below Prolog’s grammar rules are used for an <em>automatic</em> translation of R expressions to MathML. The result can then be used for calculations or it can be rendered on a web page. A limited set of rules for translation from R to MathML is found in <code>pl/mathml.pl</code> of the rolog package. The relevant code snippets are shown in the listings below, along with their output.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="kw">library</span>(rolog)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a><span class="kw">consult</span>(<span class="kw">system.file</span>(<span class="kw">file.path</span>(<span class="st">&quot;pl&quot;</span>, <span class="st">&quot;mathml.pl&quot;</span>), <span class="dt">package=</span><span class="st">&quot;rolog&quot;</span>))</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a><span class="co"># R interface to Prolog predicate r2mathml/2</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a>mathml =<span class="st"> </span><span class="cf">function</span>(term)</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a>{</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true"></a>  t =<span class="st"> </span><span class="kw">once</span>(<span class="kw">call</span>(<span class="st">&quot;r2mathml&quot;</span>, term, <span class="kw">expression</span>(X)))</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true"></a>  <span class="kw">cat</span>(<span class="kw">paste</span>(t<span class="op">$</span>X, <span class="dt">collapse=</span><span class="st">&quot;&quot;</span>))</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true"></a>}</span></code></pre></div>
<dl>
<dt>Listing 4</dt>
<dd>Using rolog to generate MathML from R expressions
</dd>
</dl>
<p>The first example is easy. At the Prolog end, there is a handler for <code>pbinom/3</code> that translates the term into a pretty MathML syntax like P_bi(X &lt;= k; N, pi).</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a>term =<span class="st"> </span><span class="kw">quote</span>(<span class="kw">pbinom</span>(k, N, p))</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a><span class="co"># Pretty print</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a><span class="kw">mathml</span>(term)</span></code></pre></div>
<p><math><mrow><msub><mi>P</mi><mtext>Bi</mtext></msub><mo>⁡</mo><mrow><mo>(</mo><mrow><mrow><mi>X</mi><mo>≤</mo><mi>k</mi></mrow><mo>;</mo><mrow><mi>N</mi><mo>,</mo><mi>p</mi></mrow></mrow><mo>)</mo></mrow></mrow></math></p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a><span class="co"># Do some calculations with the same term</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a>k =<span class="st"> </span><span class="dv">10</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a>N =<span class="st"> </span><span class="dv">22</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a>p =<span class="st"> </span><span class="fl">0.4</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true"></a><span class="kw">eval</span>(term)</span></code></pre></div>
<p>[1] 0.77195</p>
<p>The next example is interesting because Prolog needs to find out the name of the integration variable for <code>sin</code>. For that purpose, rolog provides a predicate <code>r_eval/2</code> that calls R from Prolog (i.e., the reverse direction, see also next example). Here, the predicate is used for the R function <code>formalArgs(args(sin))</code>, which returns the name of the function argument of <code>sin</code>, that is, <code>x</code>.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a>term =<span class="st"> </span><span class="kw">quote</span>(<span class="kw">integrate</span>(sin, 0L, 2L<span class="op">*</span>pi))</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a><span class="kw">mathml</span>(term)</span></code></pre></div>
<p><math><mrow><munderover><mo>∫</mo><mn>0</mn><mrow><mn>2</mn><mo>⁢</mo><mi>π</mi></mrow></munderover><mrow><mi>sin</mi><mo>⁡</mo><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mrow><mspace width="thinmathspace"></mspace><mi>d</mi><mi>x</mi></mrow></math></p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="kw">eval</span>(term)</span></code></pre></div>
<p>2.221501e-16 with absolute error &lt; 4.4e-14</p>
<p>Note that the Prolog end, the handler for <code>integrate/3</code> is rather rigid; it accepts only these three arguments in that particular order, and without names, that is, <code>integrate(sin, lower=0L, upper=2L * pi)</code> would not print the desired result.</p>
<p>Therefore, <code>pl/mathml.pl</code> includes two handlers that accept terms with named arguments, <code>integrate(f=Fn, lower=Lower, upper=Upper)</code>, as well as terms of the form <code>$(integrate(Fn, Lower, Upper), value)</code> that are needed for the evaluation below.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="co"># Apply match.call to all components of a term</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a>canonical &lt;-<span class="st"> </span><span class="cf">function</span>(term)</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a>{</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a>  <span class="cf">if</span>(<span class="kw">is.call</span>(term))</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a>  {</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true"></a>    f &lt;-<span class="st"> </span><span class="kw">match.fun</span>(term[[<span class="dv">1</span>]])</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true"></a>    <span class="cf">if</span>(<span class="op">!</span><span class="kw">is.primitive</span>(f))</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true"></a>      term &lt;-<span class="st"> </span><span class="kw">match.call</span>(f, term)</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true"></a>    </span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true"></a>    <span class="co"># Recurse into arguments</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true"></a>    term[<span class="op">-</span><span class="dv">1</span>] &lt;-<span class="st"> </span><span class="kw">lapply</span>(term[<span class="op">-</span><span class="dv">1</span>], canonical)</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true"></a>  }</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true"></a></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true"></a>  <span class="kw">return</span>(term)</span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true"></a>}</span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true"></a></span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true"></a><span class="co"># A custom function</span></span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true"></a>g &lt;-<span class="st"> </span><span class="cf">function</span>(u)</span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true"></a>{</span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true"></a>  <span class="kw">sin</span>(u)</span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true"></a>}</span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true"></a></span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true"></a><span class="co"># Mixture of (partially) named and positional arguments in unusual order</span></span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true"></a>term &lt;-<span class="st"> </span><span class="kw">quote</span>(2L <span class="op">*</span><span class="st"> </span><span class="kw">integrate</span>(<span class="dt">low=</span><span class="op">-</span><span class="ot">Inf</span>, <span class="dt">up=</span><span class="ot">Inf</span>, g)<span class="op">$</span>value)</span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true"></a><span class="kw">mathml</span>(<span class="kw">canonical</span>(term))</span></code></pre></div>
<p><math><mrow><mn>2</mn><mo>⋅</mo><mrow><munderover><mo>∫</mo><mrow><mo>-</mo><mi>∞</mi></mrow><mi>∞</mi></munderover><mrow><mi>g</mi><mo>⁡</mo><mrow><mo>(</mo><mi>u</mi><mo>)</mo></mrow></mrow><mspace width="thinmathspace"></mspace><mi>d</mi><mi>u</mi></mrow></mrow></math></p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a><span class="co"># It is a bit of a mystery that R knows the result of this integral.</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a><span class="kw">eval</span>(term)</span></code></pre></div>
<p>[1] 0</p>
<p>The extra R function <code>canonical()</code> applies <code>match.call()</code> to non-primitive R calls, basically cleaning up the arguments and bringing them into the correct order.</p>
</div>
<div id="calling-prolog-from-r" class="section level2">
<h2>Calling Prolog from R</h2>
<p>The basic workflow of the bridge from R to Prolog is to (A)~translate an R~expression into a Prolog term (i.e., a predicate), (B)~query the predicate, and then, (C)~translate the result (i.e., the bindings of the variables) back to R. The reverse direction is straightforward, we start by translating a Prolog~term to an R~expression (i.e. Step~C), evaluate the R~expression, and then translate the result back to a Prolog~term (Step~A). <code>rolog</code> provides two predicates for that purpose, <code>r_eval(Expr)</code> and <code>r_eval(Expr, Res)</code>. The former is used to invoke an R~expression <em>Expr</em> for its side effects (e.g., initializing a random number generator); it does not return a result. The latter is used to evaluate the R~expression <em>Expr</em> and return the result <em>Res</em>. The code snippet in Listing 6 (<code>r_eval.pl</code>) illustrates this behavior.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a>r_seed(<span class="dt">Seed</span>) <span class="kw">:-</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a>    r_eval(<span class="st">&#39;</span><span class="er">set</span><span class="st">.</span><span class="er">seed</span><span class="st">&#39;</span>(<span class="dt">Seed</span>))<span class="kw">.</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true"></a>r_norm(<span class="dt">N</span><span class="kw">,</span> <span class="dt">L</span>) <span class="kw">:-</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true"></a>    r_eval(rnorm(<span class="dt">N</span>)<span class="kw">,</span> <span class="dt">L</span>)<span class="kw">.</span></span></code></pre></div>
<dl>
<dt>Listing 6</dt>
<dd>Calling R from Prolog using <code>r_eval/1</code> and <code>r_eval/2</code>. The R call <code>set.seed</code> is quoted because the dot is an operator in Prolog.
</dd>
</dl>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a><span class="kw">consult</span>(<span class="kw">system.file</span>(<span class="kw">file.path</span>(<span class="st">&quot;pl&quot;</span>, <span class="st">&quot;r_eval.pl&quot;</span>), <span class="dt">package=</span><span class="st">&quot;rolog&quot;</span>))</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a><span class="kw">invisible</span>(<span class="kw">once</span>(<span class="kw">call</span>(<span class="st">&quot;r_seed&quot;</span>, <span class="dv">1234</span>)))</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true"></a><span class="kw">once</span>(<span class="kw">call</span>(<span class="st">&quot;r_norm&quot;</span>, 3L, <span class="kw">expression</span>(X)))</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true"></a><span class="co">#&gt; $X</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true"></a><span class="co">#&gt; [1] -1.2070657  0.2774292  1.0844412</span></span></code></pre></div>
<p>The example in Listing 6 is a bit trivial, basically illustrating the syntax and the workflow. More serious applications of <code>r_eval/1,2</code> are illustrated in the example on mathematical expressions where <code>r_eval/2</code> is used to obtain the name of a function argument, as well as in the next example on interval arithmetic, where <code>r_eval/2</code> is used to evaluate monotonically behaving R functions.</p>
</div>
<div id="interval-arithmetic" class="section level2">
<h2>Interval arithmetic</h2>
<p>Let <span class="math inline">\(\langle\ell, u\rangle\)</span> denote a number between <span class="math inline">\(\ell\)</span> and <span class="math inline">\(u\)</span>, <span class="math inline">\(\ell\le u\)</span>. It is easily verified that the result of the difference <span class="math inline">\(\langle\ell_1, u_1\rangle - \langle\ell_2, u_2\rangle\)</span> is somewhere in the interval <span class="math inline">\(\langle \ell_1 - u_2, u_1 - \ell_2\rangle\)</span>, and a number of rules exist for basic arithmetic operations and (piecewise) monotonically behaving functions <span class="citation">(Hickey, Ju, and Emden 2001)</span>. For ratios, denominators with mixed sign yield two possible intervals, for example, <span class="math inline">\(\langle 1, 2\rangle / \langle -3, 3\rangle = \langle -\infty, 3\rangle \cup \langle 3, \infty\rangle\)</span>, as shown in Figure 4 in Hickey et al.’s article. The number of possible candidates increases if more complicated functions are involved, as unions of intervals themselves appear as arguments (e.g., if <span class="math inline">\(I_1 \cup I_2\)</span> is added to <span class="math inline">\(I_3 \cup I_4\)</span>, the result is <span class="math inline">\(I_1 + I_3 \cup I_1 + I_4 \cup I_2 + I_3 \cup I_2 + I_4\)</span>). As a consequence, calculations in interval arithmetic are non-deterministic in nature, and the number of possible results is not foreseeable and cannot, in general, be vectorized as is often done in R. Use cases for interval arithmetic are the limitations of floating-point representations in computer hardware, but intervals can also be used to represent the result of measurements with limited precision, or truncated intermediate results of students doing hand calculations. A few rules for basic interval arithmetic are found in <code>pl/interval.pl</code>; a few examples are shown below. Again, Prolog rings back to R via <code>r_eval/2</code> to determine the result of <code>dbinom(X, Size, Prob, Log)</code>.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a><span class="kw">consult</span>(<span class="kw">system.file</span>(<span class="kw">file.path</span>(<span class="st">&quot;pl&quot;</span>, <span class="st">&quot;interval.pl&quot;</span>), <span class="dt">package=</span><span class="st">&quot;rolog&quot;</span>))</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true"></a></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true"></a>Q &lt;-<span class="st"> </span><span class="kw">quote</span>(<span class="kw">int</span>(<span class="st">`</span><span class="dt">...</span><span class="st">`</span>(<span class="dv">1</span>, <span class="dv">2</span>) <span class="op">/</span><span class="st"> `</span><span class="dt">...</span><span class="st">`</span>(<span class="op">-</span><span class="dv">3</span>, <span class="dv">3</span>), .Res))</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true"></a><span class="kw">unlist</span>(<span class="kw">findall</span>(<span class="kw">as.rolog</span>(Q)))</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true"></a><span class="co">#&gt; $Res</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true"></a><span class="co">#&gt; ...(-Inf, -0.333333333333333)</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true"></a><span class="co">#&gt; </span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true"></a><span class="co">#&gt; $Res</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true"></a><span class="co">#&gt; ...(0.333333333333333, Inf)</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true"></a></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true"></a>D  &lt;-<span class="st"> </span><span class="kw">quote</span>(<span class="st">`</span><span class="dt">...</span><span class="st">`</span>(<span class="fl">5.7</span>, <span class="fl">5.8</span>))</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true"></a>mu &lt;-<span class="st"> </span><span class="dv">4</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true"></a>s  &lt;-<span class="st"> </span><span class="kw">quote</span>(<span class="st">`</span><span class="dt">...</span><span class="st">`</span>(<span class="fl">3.8</span>, <span class="fl">3.9</span>))</span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true"></a>N  &lt;-<span class="st"> </span>24L</span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true"></a>tratio &lt;-<span class="st"> </span><span class="kw">call</span>(<span class="st">&quot;/&quot;</span>, <span class="kw">call</span>(<span class="st">&quot;-&quot;</span>, D, mu), <span class="kw">call</span>(<span class="st">&quot;/&quot;</span>, s, <span class="kw">call</span>(<span class="st">&quot;sqrt&quot;</span>, N)))</span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true"></a><span class="kw">once</span>(<span class="kw">call</span>(<span class="st">&quot;int&quot;</span>, tratio, <span class="kw">expression</span>(Res)))</span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true"></a><span class="co">#&gt; $Res</span></span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true"></a><span class="co">#&gt; ...(2.13545259627251, 2.32056923000512)</span></span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true"></a></span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true"></a><span class="co"># Binomial density</span></span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true"></a>prob =<span class="st"> </span><span class="kw">quote</span>(<span class="st">`</span><span class="dt">...</span><span class="st">`</span>(<span class="fl">0.2</span>, <span class="fl">0.3</span>))</span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true"></a><span class="kw">once</span>(<span class="kw">call</span>(<span class="st">&quot;int&quot;</span>, <span class="kw">call</span>(<span class="st">&quot;dbinom&quot;</span>, 4L, 10L, prob, <span class="ot">FALSE</span>), <span class="kw">expression</span>(Res)))</span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true"></a><span class="co">#&gt; $Res</span></span>
<span id="cb28-24"><a href="#cb28-24" aria-hidden="true"></a><span class="co">#&gt; ...(0.088080384, 0.200120949)</span></span></code></pre></div>
<p>The slightly cumbersome syntax for entering an interval <span class="math inline">\(\langle \ell, u\rangle\)</span> is due to the fact that the ellipsis is a reserved symbol in R and cannot be used as an infix operator. A powerful and comprehensive system for constraint logic programming over intervals is available as a Prolog pack <span class="citation">(Workman 2021)</span> and can easily be connected to R using, for example, the present package.</p>
</div>
</div>
<div id="conclusions" class="section level1">
<h1>5. Conclusions</h1>
<p>R has become the primary language for statistical programming and data science, but is currently lacking support for traditional, symbolic artificial intelligence. There are already two add-ons for SWI-Prolog that allow to run R calculations from Prolog <span class="citation">(Angelopoulos et al. 2013; Wielemaker 2021b)</span>, but a connection in the other direction was missing, so far. <code>rolog</code> bridges this gap by providing an interface to a SWI-Prolog distribution embedded into an R package. The communication between the two systems is mainly in the form of queries from R to Prolog, but two predicates allow Prolog to ring back and evaluate terms in R. The design of the package is minimalistic, providing three main functions <code>query()</code>, <code>submit()</code>, and <code>clear()</code>, and a very limited set of convenience tools (<code>consult()</code>, <code>once()</code>, and <code>findall()</code>) to facilitate recurrent everyday actions. As both systems are homoiconic in nature, it was easy to establish a one-to-one correspondence between many of the elements of the two languages. Most exceptions (e.g., lack of R support for empty symbols) can be avoided and/or circumvented by wrapper functions at both ends.</p>
<p>Simple ways to extend the package have been described in Section 2; such extensions could, for example, include R objects and structures like those returned by <code>lm()</code>, or S4 classes. In many use cases, this may be realized by transforming the R object to a list with named elements, and rebuild the object on the Prolog end on an as-needed basis. After a query, the process is reversed. If speed is an issue, more of these steps can, in principle, be moved into the package and implemented in <code>Rcpp</code>.</p>
<p><code>rolog</code>, thus, opens up a wide of applications in logic programming for statisticians and researchers at the intersection of symbolic and connectionist artificial intelligence, where concise knowledge representation is combined with statistical power. Moreover, <code>rolog</code> provides starting points for useful small-scale solutions for everyday issues in data science (term transformations, pretty mathematical output, interval arithmetic, see Section 3).</p>
<p>At its present stage, a major limitation of <code>rolog</code> is its relatively slow speed. For example, translation of R lists or vectors to the respective elements of the Prolog language (also lists, <code>#/N</code>) is done element-wise, in both directions. The translation is optimized by using <code>Rcpp</code> <span class="citation">(Eddelbuettel and Balamuta 2018)</span>, but there remains an upper bound in the efficiency, because Prolog does not support vectors or matrices. Since Prolog’s primary purpose is not vector or matrix calculation, this limitation may not show up in real-world applications. Another issue, maybe a bit annoying, is the rather cumbersome syntax of the interface, with the need for quoted calls and R expressions for representing Prolog variables. <code>rolog</code> was deliberately chosen to be minimalistic and, so far, only depends on base R. A more concise representation might be obtained by tools from the “Tidyverse” ecosystem, as described in Chapter 19 of Advanced R <span class="citation">(Wickham 2019)</span>. Finally, at this stage, <code>rolog</code> is unable to deal with cyclic terms (e.g., <code>once(call(&quot;=&quot;, expression(A), call(&quot;f&quot;, expression(A))))</code>, i.e., <code>A = f(A)</code> raises an error message).</p>
<p><code>rolog</code> is available for R Version 4.2 and later, and can easily be installed using the usual <code>install.packages(&quot;rolog&quot;)</code>. The source code of the package is found at <a href="https://github.com/mgondan/rolog/" class="uri">https://github.com/mgondan/rolog/</a>, including installation instructions for Unix, Windows and macOS.</p>
</div>
<div id="acknowledgement" class="section level1">
<h1>Acknowledgement</h1>
<p>Development of the package profited substantially from the Prolog packs <code>rserve_client</code> <span class="citation">(Wielemaker 2021b)</span> and <code>real</code> <span class="citation">(Angelopoulos et al. 2013)</span>.</p>
</div>
<div id="note" class="section level1">
<h1>Note</h1>
<p>The results in this paper were obtained using R 2.0.2022 with the <code>rolog</code>~0.9.4 package. R itself and all packages used are available from the Comprehensive R Archive Network (CRAN) at <a href="https://CRAN.R-project.org/" class="uri">https://CRAN.R-project.org/</a>.</p>
</div>
<div id="references" class="section level1 unnumbered">
<h1 class="unnumbered">References</h1>
<div id="refs" class="references hanging-indent">
<div id="ref-Angelopoulos2013">
<p>Angelopoulos, Nicos, Vitor Santos Costa, Joao Azevedo, Jan Wielemaker, Rui Camacho, and Lodewyk Wessels. 2013. “Integrative Functional Statistics in Logic Programming.” In <em>Proceedings of Practical Aspects of Declarative Languages</em>, 7752:190–205. LNCS. Rome, Italy.</p>
</div>
<div id="ref-Angelopoulos2008">
<p>Angelopoulos, Nicos, and James Cussens. 2008. “Bayesian Learning of Bayesian Networks with Informative Priors.” <em>Journal of Annals of Mathematics and Artificial Intelligence</em> 54: 53–98.</p>
</div>
<div id="ref-YapR">
<p>Azevedo, J. 2011. <em>YapR</em>. <a href="https://github.com/jcazevedo/YapR">https://github.com/jcazevedo/YapR</a>.</p>
</div>
<div id="ref-ggdag">
<p>Barrett, Malcolm. 2021. <em>Ggdag: Analyze and Create Elegant Directed Acyclic Graphs</em>. <a href="https://CRAN.R-project.org/package=ggdag">https://CRAN.R-project.org/package=ggdag</a>.</p>
</div>
<div id="ref-Brown1978">
<p>Brown, J. S., and R. R. Burton. 1978. “Diagnostic Models for Procedural Bugs in Basic Mathematical Skills.” <em>Cognitive Science</em> 2: 155–92.</p>
</div>
<div id="ref-Carro2004">
<p>Carro, Manuel. 2004. <em>An Application of Rational Trees in a Logic Programming Interpreter for a Procedural Language</em>. Technical University of Madrid: School of ComputerScience.</p>
</div>
<div id="ref-Cussens2000">
<p>Cussens, James. 2000. “Stochastic Logic Programs: Sampling, Inference and Applications.” In <em>Sixteenth Annual Conference on Uncertainty in Artificial Intelligence (Uai’00)</em>, edited by Thomas J. Bergin Jr. and Richard G. Gibson Jr., 115–22. San Francisco, CA: Morgan Kaufmann Publishers.</p>
</div>
<div id="ref-Dahl1981">
<p>Dahl, V. 1981. “Translating Spanish into Logic Through Logic.” <em>American Journal of Computational Linguistics</em> 7 (3): 149–64.</p>
</div>
<div id="ref-Edelbuettel2018">
<p>Eddelbuettel, Dirk, and James Joseph Balamuta. 2018. “Extending R with C++: A Brief Introduction to Rcpp.” <em>The American Statistician</em> 72 (1): 28–36. <a href="https://doi.org/10.1080/00031305.2017.1375990">https://doi.org/10.1080/00031305.2017.1375990</a>.</p>
</div>
<div id="ref-Fruehwirth1998">
<p>Frühwirth, T. 1998. “Theory and Practice of Constraint Handling Rules.” <em>Journal of Logic Programming</em> 37: 95–138.</p>
</div>
<div id="ref-greenland1999">
<p>Greenland, S., J. Pearl, and J. M. Robins. 1999. “Causal Diagrams for Epidemiologic Research.” <em>Epidemiology</em> 10: 37–48.</p>
</div>
<div id="ref-Hickey2001">
<p>Hickey, T., Q. Ju, and M. H. van Emden. 2001. “Interval Arithmetic: From Principles to Implementation.” <em>Journal of the ACM</em> 48: 1038–68.</p>
</div>
<div id="ref-Hsiang1987">
<p>Hsiang, Jieh, and Mandayam Srivas. 1987. “Automatic Inductive Theorem Proving Using Prolog.” <em>Theoretical Computer Science</em> 54 (1): 3–28.</p>
</div>
<div id="ref-Kimmig2011">
<p>Kimmig, Angelika, Bart Demoen, Luc De Raedt, Vítor Santos Costa, and Ricardo Rocha. 2011. “On the Implementation of the Probabilistic Logic Programming Language Problog.” <em>Theory and Practice of Logic Programming</em> 11: 235–326.</p>
</div>
<div id="ref-Kowalski1988">
<p>Kowalski, Robert A. 1988. “The Early Years of Logic Programming.” <em>Communications of the ACM</em> 31 (38).</p>
</div>
<div id="ref-Lally2011">
<p>Lally, Adam, and Paul Fodor. 2011. “Natural Language Processing with Prolog in the Ibm Watson System.”</p>
</div>
<div id="ref-Newell1972">
<p>Newell, Alan, and Herbert A. Simon. 1972. <em>Human Problem Solving</em>. Englewood Cliffs, NJ: Prentice-Hall.</p>
</div>
<div id="ref-R">
<p>R Core Team. 2021. <em>R: A Language and Environment for Statistical Computing</em>. Vienna, Austria: R Foundation for Statistical Computing. <a href="https://www.R-project.org/">https://www.R-project.org/</a>.</p>
</div>
<div id="ref-Sarkar2022">
<p>Sarkar, Deepayan, and Kurt Hornik. 2022. <em>Enhancements to HTML Documentation</em>. <a href="https://blog.r-project.org/2022/04/08/enhancements-to-html-documentation/index.html">https://blog.r-project.org/2022/04/08/enhancements-to-html-documentation/index.html</a>.</p>
</div>
<div id="ref-Sato2001">
<p>Sato, Taisuke, and Yoshitaka Kameya. 2013. “Parameter Learning of Logic Programs for Symbolic Statistical Modeling.” <em>Journal of AI Research</em> 15: 391–454.</p>
</div>
<div id="ref-Shoham1994">
<p>Shoham, Yoav. 1994. <em>Artificial Intelligence Techniques in Prolog</em>. San Francisco: Morgan Kaufman.</p>
</div>
<div id="ref-Triska2018">
<p>Triska, Markus. 2018. “Boolean Constraints in SWI-Prolog: A Comprehensive System Description.” <em>Science of Computer Programming</em> 164: 98–115.</p>
</div>
<div id="ref-Urbanek2021">
<p>Urbanek, Simon. 2021. <em>Rserve: Binary R Server</em>. <a href="https://CRAN.R-project.org/package=Rserve">https://CRAN.R-project.org/package=Rserve</a>.</p>
</div>
<div id="ref-Wickham2019">
<p>Wickham, H. 2019. <em>Advanced R</em>. Cambridge: Chapman and Hall/CRC.</p>
</div>
<div id="ref-Environ">
<p>Wielemaker, Jan. 2012. <em>Demo Package with c Code, Fetching the Program Environment</em>. <a href="https://www.swi-prolog.org/pack/list?p=environ">https://www.swi-prolog.org/pack/list?p=environ</a>.</p>
</div>
<div id="ref-Wielemaker2021">
<p>———. 2021a. <em>A C++ Interface to Swi-Prolog</em>. <a href="https://www.swi-prolog.org/pldoc/man?section=cpp-intro">https://www.swi-prolog.org/pldoc/man?section=cpp-intro</a>.</p>
</div>
<div id="ref-Rserve">
<p>———. 2021b. <em>Rserve Client for Swi-Prolog/Swish</em>. <a href="https://github.com/JanWielemaker/rserve_client">https://github.com/JanWielemaker/rserve_client</a>.</p>
</div>
<div id="ref-SWISH">
<p>Wielemaker, Jan, Torbjörn Lager, and Fabrizio Riguzzi. 2015. “SWISH: Swi-Prolog for Sharing.” <em>CoRR</em> abs/1511.00915. <a href="https://arxiv.org/abs/1511.00915">https://arxiv.org/abs/1511.00915</a>.</p>
</div>
<div id="ref-Wielemaker2012">
<p>Wielemaker, Jan, Tom Schrijvers, Markus Triska, and Torbjörn Lager. 2012. “SWI-Prolog.” <em>Theory and Practice of Logic Programming</em> 12 (1-2): 67–96. <a href="https://doi.org/10.1017/S1471068411000494">https://doi.org/10.1017/S1471068411000494</a>.</p>
</div>
<div id="ref-Workman2021">
<p>Workman, R. 2021. <em>ClpBNR. Von Clp over Reals Using Interval Arithmetic. Includes Rational, Integer and Boolean Domains as Subsets</em>. <a href="https://github.com/ridgeworks/clpBNR">https://github.com/ridgeworks/clpBNR</a>.</p>
</div>
<div id="ref-Xie2020">
<p>Xie, Y., C. Dervieux, and E. Riederer. 2020. <em>R Markdown Cookbook</em>. Cambridge: Chapman and Hall/CRC.</p>
</div>
<div id="ref-Zinda2021">
<p>Zinda, Eric. 2021. <em>MQI – Python and Other Programming Languge Integration for Swi Prolog</em>. <a href="https://www.swi-prolog.org/pldoc/man?section=mqi-overview">https://www.swi-prolog.org/pldoc/man?section=mqi-overview</a>.</p>
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
